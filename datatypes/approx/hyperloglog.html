<html><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><title>Algebird</title><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="Abstract Algebra for Scala." /><meta name="author" content="Algebird's contributors" /><meta name="og:image" content="/algebird/img/poster.png" /><meta name="og:title" content="Algebird" /><meta name="og:site_name" content="Algebird" /><meta name="og:url" content="http://twitter.github.io/algebird" /><meta name="og:type" content="website" /><meta name="og:description" content="Abstract Algebra for Scala." /><meta name="twitter:image" content="/algebird/img/poster.png" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:site" content="" /><link rel="icon" type="image/png" href="/algebird/img/favicon.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/algebird/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/algebird/css/style.css" /><link rel="stylesheet" href="/algebird/css/palette.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/algebird/" class="brand"><div class="brand-wrapper" style="background:url('/algebird/img/sidebar_brand.png') no-repeat"><span>Algebird</span></div></a></li> <li><a href="/algebird/datatypes.html" class="">Data Types</a></li> <li><a href="/algebird/datatypes/combinator.html" class="">Combinators</a> <ul class="sub_section"> <li><a href="/algebird/datatypes/combinator/collections.html" class="">Scala Collections</a></li> <li><a href="/algebird/datatypes/combinator/java_collections.html" class="">Java Collections</a></li> <li><a href="/algebird/datatypes/combinator/option_monoid.html" class="">Option Monoid</a></li> <li><a href="/algebird/datatypes/combinator/caseclass.html" class="">Case Class Algebra</a></li> <li><a href="/algebird/datatypes/combinator/cuber.html" class="">Cuber</a></li> <li><a href="/algebird/datatypes/combinator/roller.html" class="">Roller</a></li> <li><a href="/algebird/datatypes/combinator/eventually.html" class="">Eventually</a></li> <li><a href="/algebird/datatypes/combinator/priority.html" class="">Priority</a></li> <li><a href="/algebird/datatypes/combinator/product_algebra.html" class="">Product/Tuple Algebra</a></li> <li><a href="/algebird/datatypes/combinator/monoid_statistics.html" class="">Monoid Statistics</a></li></ul></li> <li><a href="/algebird/datatypes/approx.html" class="">Approximate Data Types</a> <ul class="sub_section"> <li><a href="/algebird/datatypes/approx/approximate.html" class="">Approximate</a></li> <li><a href="/algebird/datatypes/approx/bloom_filter.html" class="">Bloom Filter</a></li> <li><a href="/algebird/datatypes/approx/countminsketch.html" class="">Count Min Sketch</a></li> <li><a href="/algebird/datatypes/approx/exponential_histogram.html" class="">Exponential Histogram</a></li> <li><a href="/algebird/datatypes/approx/hyperloglog.html" class=" active ">HyperLogLog</a></li> <li><a href="/algebird/datatypes/approx/hyperloglog_series.html" class="">HyperLogLog Series</a></li> <li><a href="/algebird/datatypes/approx/min_hasher.html" class="">MinHasher</a></li> <li><a href="/algebird/datatypes/approx/q_tree.html" class="">Q Tree</a></li> <li><a href="/algebird/datatypes/approx/space_saver.html" class="">SpaceSaver</a></li></ul></li> <li><a href="/algebird/datatypes/summer.html" class="">Summers</a> <ul class="sub_section"> <li><a href="/algebird/datatypes/summer/adaptive_cache.html" class="">AdaptiveCache</a></li> <li><a href="/algebird/datatypes/summer/batched.html" class="">Batched</a></li> <li><a href="/algebird/datatypes/summer/sum_all.html" class="">SumAll</a></li> <li><a href="/algebird/datatypes/summer/summingcache.html" class="">SummingCache</a></li> <li><a href="/algebird/datatypes/summer/summingiterator.html" class="">SummingIterator</a></li> <li><a href="/algebird/datatypes/summer/summingqueue.html" class="">SummingQueue</a></li></ul></li> <li><a href="/algebird/datatypes/min_and_max.html" class="">Ordered Semigroups</a> <ul class="sub_section"> <li><a href="/algebird/datatypes/first_and_last.html" class="">First and Last</a></li> <li><a href="/algebird/datatypes/min_and_max.html" class="">Min and Max</a></li></ul></li> <li><a href="/algebird/datatypes/adaptive_matrix.html" class="">Adaptive Matrix</a></li> <li><a href="/algebird/datatypes/adaptive_vector.html" class="">Adaptive Vector</a></li> <li><a href="/algebird/datatypes/affine_function.html" class="">Affine Function</a></li> <li><a href="/algebird/datatypes/averaged_value.html" class="">Averaged Value</a></li> <li><a href="/algebird/datatypes/bytes.html" class="">Bytes</a></li> <li><a href="/algebird/datatypes/decayed_value.html" class="">Decayed Value</a></li> <li><a href="/algebird/datatypes/decayed_vector.html" class="">Decayed Vector</a></li> <li><a href="/algebird/datatypes/five_moments.html" class="">First Five Moments</a></li> <li><a href="/algebird/datatypes/gaussian_distribution.html" class="">Gaussian Distribution</a></li> <li><a href="/algebird/datatypes/interval.html" class="">Interval</a></li> <li><a href="/algebird/datatypes/min_plus_algebra.html" class="">Min Plus Algebra</a></li> <li><a href="/algebird/datatypes/reset_state.html" class="">ResetState</a></li> <li><a href="/algebird/datatypes/right_folded.html" class="">RightFolded</a></li> <li><a href="/algebird/datatypes/set_diff.html" class="">SetDiff</a></li> <li><a href="/algebird/datatypes/sgd.html" class="">Stochastic Gradient Descent</a></li> <li><a href="/algebird/datatypes/topk.html" class="">TopK</a></li>         </ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li class="hidden-xs"><a href="https://github.com/twitter/algebird"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li class="hidden-xs"><a href="https://github.com/twitter/algebird"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Algebird Abstract Algebra for Scala.');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Algebird Abstract Algebra for Scala.');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="twitter" data-github-repo="algebird"><div class="content-wrapper"><section><h1 id="hyperloglog">HyperLogLog</h1>

<p>HyperLogLog is an approximation algorithm that estimates the number of distinct elements in a multiset using a constant amount of memory. (See https://en.wikipedia.org/wiki/HyperLogLog)</p>

<p>In Algebird, the HLL class can be used like a set. You can create an HLL from an element, and you can combine HLLs using the <code class="highlighter-rouge">+</code> operation, which is like set union. Like most structures in Algebird, HLLs form a monoid, where set union (<code class="highlighter-rouge">+</code>) is the addition operation.</p>

<p>Unlike a normal set, HLL cannot lookup whether elements are in the set. If you want to do this, consider using a BloomFilter, which can check elements for set membership, but is less memory-efficient than a HLL.</p>

<blockquote>
  <p>Note: Internally, HLL represents its elements using hashes, which are internally represented as <code class="highlighter-rouge">Array[Byte]</code>. For this reason, some HLL methods take an <code class="highlighter-rouge">Array[Byte]</code>, assuming that the user will convert the object to an <code class="highlighter-rouge">Array[Byte]</code>. However, to make using the HLLs easier, there are also generic methods that take any type <code class="highlighter-rouge">K</code> as long as there’s evidence of a <code class="highlighter-rouge">Hash128[K]</code>, which represents a 128-bit hash function for objects of type <code class="highlighter-rouge">K</code>.</p>
</blockquote>

<p>HLLs cannot be instantiated directly. Instead, you must create them using one of the following strategies:</p>

<h3 id="hyperloglogmonoid">HyperLogLogMonoid</h3>

<p>The <code class="highlighter-rouge">HyperLogLogMonoid</code> class is the simplest way to create HLLs. <code class="highlighter-rouge">HyperLogLogMonoid</code> is quite barebones, so, in most situations, it makes sense to use the <code class="highlighter-rouge">HyperLogLogAggregator</code> methods mentioned below.</p>

<h4 id="step-1-create-a-hyperloglogmonoid">Step 1: Create a HyperLogLogMonoid</h4>

<p>The HyperLogLogMonoid constructor takes an Int <code class="highlighter-rouge">bits</code>, which represents the number of bits of the hash function that the HLL uses. The more bits you use, the more space the HLLs will take up, and the more precise your estimates will be. For a better understanding of the space-to-accuracy trade-off, see <a href="https://github.com/twitter/algebird/blob/develop/algebird-core/src/main/scala/com/twitter/algebird/HyperLogLog.scala#L197">this table</a> or use one of the other strategies mentioned below, which allow you to specify the desired error.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.twitter.algebird._</span>
<span class="c1">// import com.twitter.algebird._
</span>
<span class="k">val</span> <span class="n">hllMonoid</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HyperLogLogMonoid</span><span class="o">(</span><span class="n">bits</span> <span class="k">=</span> <span class="mi">4</span><span class="o">)</span>
<span class="c1">// hllMonoid: com.twitter.algebird.HyperLogLogMonoid = com.twitter.algebird.HyperLogLogMonoid@70816c74
</span></code></pre>
</div>

<h4 id="step-2-create-hlls-from-your-data">Step 2: Create HLLs from your data</h4>

<p>HyperLogLogMonoid has a <code class="highlighter-rouge">create</code> method which takes a hashed element (as a <code class="highlighter-rouge">Array[Byte]</code>) and returns an <code class="highlighter-rouge">HLL</code> which represents a set containing the given element.</p>

<p>We can create an HLL containing a list of elements by creating HLLs for each element using the <code class="highlighter-rouge">create</code> method, and combining the elements using the HyperLogLogMonoid’s <code class="highlighter-rouge">sum</code> method.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.twitter.algebird.HyperLogLog.int2Bytes</span>
<span class="c1">// import com.twitter.algebird.HyperLogLog.int2Bytes
</span>
<span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="c1">// data: List[Int] = List(1, 1, 2, 2, 3, 3, 4, 4, 5, 5)
</span>
<span class="k">val</span> <span class="n">hlls</span> <span class="k">=</span> <span class="n">data</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">hllMonoid</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">// hlls: List[com.twitter.algebird.HLL] = List(SparseHLL(4,Map(2 -&gt; Max(1))), SparseHLL(4,Map(2 -&gt; Max(1))), SparseHLL(4,Map(2 -&gt; Max(2))), SparseHLL(4,Map(2 -&gt; Max(2))), SparseHLL(4,Map(13 -&gt; Max(1))), SparseHLL(4,Map(13 -&gt; Max(1))), SparseHLL(4,Map(4 -&gt; Max(1))), SparseHLL(4,Map(4 -&gt; Max(1))), SparseHLL(4,Map(12 -&gt; Max(1))), SparseHLL(4,Map(12 -&gt; Max(1))))
</span>
<span class="k">val</span> <span class="n">combinedHLL</span> <span class="k">=</span> <span class="n">hllMonoid</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="n">hlls</span><span class="o">)</span>
<span class="c1">// combinedHLL: com.twitter.algebird.HLL = DenseHLL(4,Bytes(0,0,2,0,1,0,0,0,0,0,0,0,1,1,0,0))
</span></code></pre>
</div>

<p>Note that we were able to call <code class="highlighter-rouge">hllMonoid.create</code> on an <code class="highlighter-rouge">Int</code> because we imported the implicit conversion <code class="highlighter-rouge">int2Bytes</code> that converts an <code class="highlighter-rouge">Int</code> into a <code class="highlighter-rouge">Array[Byte]</code>.</p>

<h4 id="step-3-approximating-set-cardinality-using-an-hll">Step 3: Approximating set cardinality using an HLL</h4>

<p>We can use the <code class="highlighter-rouge">sizeOf</code> method to estimate the approximate number of distinct elements in the multiset.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">approxSizeOf</span> <span class="k">=</span> <span class="n">hllMonoid</span><span class="o">.</span><span class="n">sizeOf</span><span class="o">(</span><span class="n">combinedHLL</span><span class="o">)</span>
<span class="c1">// approxSizeOf: com.twitter.algebird.Approximate[Long] = Approximate(1,4,9,0.9972)
</span></code></pre>
</div>

<h3 id="hyperloglogaggregator">HyperLogLogAggregator</h3>

<p>The <code class="highlighter-rouge">HyperLogLogAggregator</code> object contains some methods that make it easy to instantiate Algebird Aggregators that internally use HLLs.</p>

<p>We will only mention the generic Aggregators here. The generic aggregators require that we have an implicit <code class="highlighter-rouge">Hash128[K]</code> instance. Algebird has instances of <code class="highlighter-rouge">Hash128</code> for many common types such as <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Long</code> and <code class="highlighter-rouge">String</code>.</p>

<p>To learn more about the <code class="highlighter-rouge">Array[Byte]</code> aggregators, see <a href="https://github.com/twitter/algebird/blob/develop/algebird-core/src/main/scala/com/twitter/algebird/HyperLogLog.scala">the source code of HyperLogLog</a>.</p>

<h3 id="hyperloglogaggregatorwitherrorgenerick-hash128error-double"><code class="highlighter-rouge">HyperLogLogAggregator.withErrorGeneric[K: Hash128](error: Double)</code></h3>

<p>This is an aggregator of type <code class="highlighter-rouge">Aggregator[K, HLL, HLL]</code>, which means that it builds a <code class="highlighter-rouge">HLL</code> from a <code class="highlighter-rouge">TraversableOnce</code> of <code class="highlighter-rouge">K</code>s.
It takes an <code class="highlighter-rouge">error</code>, which must be a Double in the range (0,1).</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">agg</span> <span class="k">=</span> <span class="nc">HyperLogLogAggregator</span><span class="o">.</span><span class="n">withErrorGeneric</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mf">0.01</span><span class="o">)</span>
<span class="c1">// agg: com.twitter.algebird.GenHLLAggregator[Int] = GenHLLAggregator(com.twitter.algebird.HyperLogLogMonoid@5f19c35f,com.twitter.algebird.Hash128$$anon$5@a769e28)
</span>
<span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="c1">// data: List[Int] = List(1, 1, 2, 2, 3, 3, 4, 4, 5, 5)
</span>
<span class="k">val</span> <span class="n">combinedHll</span><span class="k">:</span> <span class="kt">HLL</span> <span class="o">=</span> <span class="n">agg</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
<span class="c1">// combinedHll: com.twitter.algebird.HLL = SparseHLL(14,Map(10388 -&gt; Max(1), 9650 -&gt; Max(1), 15708 -&gt; Max(2), 10082 -&gt; Max(3), 6205 -&gt; Max(1)))
</span></code></pre>
</div>

<h3 id="hyperloglogaggregatorwithbitsk-hash128bits-int"><code class="highlighter-rouge">HyperLogLogAggregator.withBits[K: Hash128](bits: Int)</code></h3>

<p>Similar to <code class="highlighter-rouge">withErrorGeneric</code>, but takes the number of bits as an Int.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">agg</span> <span class="k">=</span> <span class="nc">HyperLogLogAggregator</span><span class="o">.</span><span class="n">withBits</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">9</span><span class="o">)</span>
<span class="c1">// agg: com.twitter.algebird.GenHLLAggregator[Int] = GenHLLAggregator(com.twitter.algebird.HyperLogLogMonoid@7f9a7f3a,com.twitter.algebird.Hash128$$anon$5@a769e28)
</span>
<span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="c1">// data: List[Int] = List(1, 1, 2, 2, 3, 3, 4, 4, 5, 5)
</span>
<span class="k">val</span> <span class="n">combinedHll</span><span class="k">:</span> <span class="kt">HLL</span> <span class="o">=</span> <span class="n">agg</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
<span class="c1">// combinedHll: com.twitter.algebird.HLL = SparseHLL(9,Map(348 -&gt; Max(2), 61 -&gt; Max(3), 148 -&gt; Max(3), 434 -&gt; Max(2), 354 -&gt; Max(1)))
</span></code></pre>
</div>

<h3 id="hyperloglogaggregatorsizewitherrorgenerick-hash128err-double"><code class="highlighter-rouge">HyperLogLogAggregator.sizeWithErrorGeneric[K: Hash128](err: Double)</code></h3>

<p>This is an aggregator of type <code class="highlighter-rouge">Aggregator[K, HLL, Long]</code>, which means that it presents a Long value. The Long that it returns is the estimated size of the combined HLL.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">agg</span> <span class="k">=</span> <span class="nc">HyperLogLogAggregator</span><span class="o">.</span><span class="n">sizeWithErrorGeneric</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mf">0.01</span><span class="o">)</span>
<span class="c1">// agg: com.twitter.algebird.MonoidAggregator[Int,com.twitter.algebird.HLL,Long] = com.twitter.algebird.MonoidAggregator$$anon$6@2c9c4584
</span>
<span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="c1">// data: List[Int] = List(1, 1, 2, 2, 3, 3, 4, 4, 5, 5)
</span>
<span class="k">val</span> <span class="n">approximateSize</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="n">agg</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
<span class="c1">// approximateSize: Long = 5
</span></code></pre>
</div>

<h3 id="repl-tour">REPL Tour</h3>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">HyperLogLog._</span>
<span class="c1">// import HyperLogLog._
</span>
<span class="k">val</span> <span class="n">hll</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HyperLogLogMonoid</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
<span class="c1">// hll: com.twitter.algebird.HyperLogLogMonoid = com.twitter.algebird.HyperLogLogMonoid@7e5c2173
</span>
<span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="c1">// data: List[Int] = List(1, 1, 2, 2, 3, 3, 4, 4, 5, 5)
</span>
<span class="k">val</span> <span class="n">seqHll</span> <span class="k">=</span> <span class="n">data</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">hll</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">// &lt;console&gt;:21: warning: method apply in class HyperLogLogMonoid is deprecated: Use toHLL
//        val seqHll = data.map { hll(_) }
//                                ^
// seqHll: List[com.twitter.algebird.HLL] = List(SparseHLL(4,Map(2 -&gt; Max(1))), SparseHLL(4,Map(2 -&gt; Max(1))), SparseHLL(4,Map(2 -&gt; Max(2))), SparseHLL(4,Map(2 -&gt; Max(2))), SparseHLL(4,Map(13 -&gt; Max(1))), SparseHLL(4,Map(13 -&gt; Max(1))), SparseHLL(4,Map(4 -&gt; Max(1))), SparseHLL(4,Map(4 -&gt; Max(1))), SparseHLL(4,Map(12 -&gt; Max(1))), SparseHLL(4,Map(12 -&gt; Max(1))))
</span>
<span class="k">val</span> <span class="n">sumHll</span> <span class="k">=</span> <span class="n">hll</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="n">seqHll</span><span class="o">)</span>
<span class="c1">// sumHll: com.twitter.algebird.HLL = DenseHLL(4,Bytes(0,0,2,0,1,0,0,0,0,0,0,0,1,1,0,0))
</span>
<span class="k">val</span> <span class="n">approxSizeOf</span> <span class="k">=</span> <span class="n">hll</span><span class="o">.</span><span class="n">sizeOf</span><span class="o">(</span><span class="n">sumHll</span><span class="o">)</span>
<span class="c1">// approxSizeOf: com.twitter.algebird.Approximate[Long] = Approximate(1,4,9,0.9972)
</span>
<span class="k">val</span> <span class="n">actualSize</span> <span class="k">=</span> <span class="n">data</span><span class="o">.</span><span class="n">toSet</span><span class="o">.</span><span class="n">size</span>
<span class="c1">// actualSize: Int = 5
</span>
<span class="k">val</span> <span class="n">estimate</span> <span class="k">=</span> <span class="n">approxSizeOf</span><span class="o">.</span><span class="n">estimate</span>
<span class="c1">// estimate: Long = 4
</span></code></pre>
</div>

<h3 id="documentation-help">Documentation Help</h3>

<p>We’d love your help fleshing out this documentation! You can edit this page in your browser by clicking <a href="https://github.com/twitter/algebird/edit/develop/docs/src/main/tut/datatypes/approx/hyperloglog.md">this link</a>. These links might be helpful:</p>

<ul>
  <li><a href="https://github.com/twitter/algebird/blob/develop/algebird-core/src/main/scala/com/twitter/algebird/HyperLogLog.scala">HyperLogLog.scala</a></li>
  <li><a href="https://github.com/twitter/algebird/blob/develop/algebird-test/src/test/scala/com/twitter/algebird/HyperLogLogTest.scala">HyperLogLogTest.scala</a></li>
  <li><a href="https://github.com/twitter/algebird/blob/develop/algebird-benchmark/src/main/scala/com/twitter/algebird/benchmark/HllBatchCreateBenchmark.scala">HllBatchCreateBenchmark.scala</a></li>
  <li><a href="https://github.com/twitter/algebird/blob/develop/algebird-benchmark/src/main/scala/com/twitter/algebird/benchmark/HLLBenchmark.scala">HLLBenchmark.scala</a></li>
  <li><a href="https://github.com/twitter/algebird/blob/develop/algebird-benchmark/src/main/scala/com/twitter/algebird/benchmark/HLLPresentBenchmark.scala">HLLPresentBenchmark.scala</a></li>
</ul>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/algebird/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script src="/algebird/js/main.js"></script></body></html>