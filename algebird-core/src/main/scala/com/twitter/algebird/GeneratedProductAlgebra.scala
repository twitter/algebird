// following were autogenerated by scripts/product_generators.rb at 2013-04-02 22:55:47 -0400 do not edit
package com.twitter.algebird

/**
 * Combine 2 semigroups into a product semigroup
 */
class Product2HasAdditionOperator[X, A, B](apply: (A, B) => X, unapply: X => Option[(A, B)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2)) }
}

/**
 * Combine 2 monoids into a product monoid
 */
class Product2HasAdditionOperatorAndZero[X, A, B](apply: (A, B) => X, unapply: X => Option[(A, B)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2)) }
}

/**
 * Combine 2 groups into a product group
 */
class Product2Group[X, A, B](apply: (A, B) => X, unapply: X => Option[(A, B)])(implicit agroup: Group[A], bgroup: Group[B]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2)) }
}

/**
 * Combine 2 rings into a product ring
 */
class Product2Ring[X, A, B](apply: (A, B) => X, unapply: X => Option[(A, B)])(implicit aring: Ring[A], bring: Ring[B]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero)
  override def one = apply(aring.one, bring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2)) }
}
/**
 * Combine 3 semigroups into a product semigroup
 */
class Product3HasAdditionOperator[X, A, B, C](apply: (A, B, C) => X, unapply: X => Option[(A, B, C)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3)) }
}

/**
 * Combine 3 monoids into a product monoid
 */
class Product3HasAdditionOperatorAndZero[X, A, B, C](apply: (A, B, C) => X, unapply: X => Option[(A, B, C)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3)) }
}

/**
 * Combine 3 groups into a product group
 */
class Product3Group[X, A, B, C](apply: (A, B, C) => X, unapply: X => Option[(A, B, C)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3)) }
}

/**
 * Combine 3 rings into a product ring
 */
class Product3Ring[X, A, B, C](apply: (A, B, C) => X, unapply: X => Option[(A, B, C)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero)
  override def one = apply(aring.one, bring.one, cring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3)) }
}
/**
 * Combine 4 semigroups into a product semigroup
 */
class Product4HasAdditionOperator[X, A, B, C, D](apply: (A, B, C, D) => X, unapply: X => Option[(A, B, C, D)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4)) }
}

/**
 * Combine 4 monoids into a product monoid
 */
class Product4HasAdditionOperatorAndZero[X, A, B, C, D](apply: (A, B, C, D) => X, unapply: X => Option[(A, B, C, D)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4)) }
}

/**
 * Combine 4 groups into a product group
 */
class Product4Group[X, A, B, C, D](apply: (A, B, C, D) => X, unapply: X => Option[(A, B, C, D)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4)) }
}

/**
 * Combine 4 rings into a product ring
 */
class Product4Ring[X, A, B, C, D](apply: (A, B, C, D) => X, unapply: X => Option[(A, B, C, D)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4)) }
}
/**
 * Combine 5 semigroups into a product semigroup
 */
class Product5HasAdditionOperator[X, A, B, C, D, E](apply: (A, B, C, D, E) => X, unapply: X => Option[(A, B, C, D, E)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5)) }
}

/**
 * Combine 5 monoids into a product monoid
 */
class Product5HasAdditionOperatorAndZero[X, A, B, C, D, E](apply: (A, B, C, D, E) => X, unapply: X => Option[(A, B, C, D, E)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5)) }
}

/**
 * Combine 5 groups into a product group
 */
class Product5Group[X, A, B, C, D, E](apply: (A, B, C, D, E) => X, unapply: X => Option[(A, B, C, D, E)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5)) }
}

/**
 * Combine 5 rings into a product ring
 */
class Product5Ring[X, A, B, C, D, E](apply: (A, B, C, D, E) => X, unapply: X => Option[(A, B, C, D, E)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5)) }
}
/**
 * Combine 6 semigroups into a product semigroup
 */
class Product6HasAdditionOperator[X, A, B, C, D, E, F](apply: (A, B, C, D, E, F) => X, unapply: X => Option[(A, B, C, D, E, F)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6)) }
}

/**
 * Combine 6 monoids into a product monoid
 */
class Product6HasAdditionOperatorAndZero[X, A, B, C, D, E, F](apply: (A, B, C, D, E, F) => X, unapply: X => Option[(A, B, C, D, E, F)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6)) }
}

/**
 * Combine 6 groups into a product group
 */
class Product6Group[X, A, B, C, D, E, F](apply: (A, B, C, D, E, F) => X, unapply: X => Option[(A, B, C, D, E, F)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6)) }
}

/**
 * Combine 6 rings into a product ring
 */
class Product6Ring[X, A, B, C, D, E, F](apply: (A, B, C, D, E, F) => X, unapply: X => Option[(A, B, C, D, E, F)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6)) }
}
/**
 * Combine 7 semigroups into a product semigroup
 */
class Product7HasAdditionOperator[X, A, B, C, D, E, F, G](apply: (A, B, C, D, E, F, G) => X, unapply: X => Option[(A, B, C, D, E, F, G)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7)) }
}

/**
 * Combine 7 monoids into a product monoid
 */
class Product7HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G](apply: (A, B, C, D, E, F, G) => X, unapply: X => Option[(A, B, C, D, E, F, G)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7)) }
}

/**
 * Combine 7 groups into a product group
 */
class Product7Group[X, A, B, C, D, E, F, G](apply: (A, B, C, D, E, F, G) => X, unapply: X => Option[(A, B, C, D, E, F, G)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7)) }
}

/**
 * Combine 7 rings into a product ring
 */
class Product7Ring[X, A, B, C, D, E, F, G](apply: (A, B, C, D, E, F, G) => X, unapply: X => Option[(A, B, C, D, E, F, G)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7)) }
}
/**
 * Combine 8 semigroups into a product semigroup
 */
class Product8HasAdditionOperator[X, A, B, C, D, E, F, G, H](apply: (A, B, C, D, E, F, G, H) => X, unapply: X => Option[(A, B, C, D, E, F, G, H)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8)) }
}

/**
 * Combine 8 monoids into a product monoid
 */
class Product8HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H](apply: (A, B, C, D, E, F, G, H) => X, unapply: X => Option[(A, B, C, D, E, F, G, H)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8)) }
}

/**
 * Combine 8 groups into a product group
 */
class Product8Group[X, A, B, C, D, E, F, G, H](apply: (A, B, C, D, E, F, G, H) => X, unapply: X => Option[(A, B, C, D, E, F, G, H)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8)) }
}

/**
 * Combine 8 rings into a product ring
 */
class Product8Ring[X, A, B, C, D, E, F, G, H](apply: (A, B, C, D, E, F, G, H) => X, unapply: X => Option[(A, B, C, D, E, F, G, H)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8)) }
}
/**
 * Combine 9 semigroups into a product semigroup
 */
class Product9HasAdditionOperator[X, A, B, C, D, E, F, G, H, I](apply: (A, B, C, D, E, F, G, H, I) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9)) }
}

/**
 * Combine 9 monoids into a product monoid
 */
class Product9HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I](apply: (A, B, C, D, E, F, G, H, I) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9)) }
}

/**
 * Combine 9 groups into a product group
 */
class Product9Group[X, A, B, C, D, E, F, G, H, I](apply: (A, B, C, D, E, F, G, H, I) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9)) }
}

/**
 * Combine 9 rings into a product ring
 */
class Product9Ring[X, A, B, C, D, E, F, G, H, I](apply: (A, B, C, D, E, F, G, H, I) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9)) }
}
/**
 * Combine 10 semigroups into a product semigroup
 */
class Product10HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J](apply: (A, B, C, D, E, F, G, H, I, J) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9), jsemigroup.plus(lTuple._10, rTuple._10)) }
}

/**
 * Combine 10 monoids into a product monoid
 */
class Product10HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J](apply: (A, B, C, D, E, F, G, H, I, J) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero, jmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9), jmonoid.plus(lTuple._10, rTuple._10)) }
}

/**
 * Combine 10 groups into a product group
 */
class Product10Group[X, A, B, C, D, E, F, G, H, I, J](apply: (A, B, C, D, E, F, G, H, I, J) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero, jgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9), jgroup.negate(tuple._10)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9), jgroup.plus(lTuple._10, rTuple._10)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9), jgroup.minus(lTuple._10, rTuple._10)) }
}

/**
 * Combine 10 rings into a product ring
 */
class Product10Ring[X, A, B, C, D, E, F, G, H, I, J](apply: (A, B, C, D, E, F, G, H, I, J) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero, jring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one, jring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9), jring.negate(tuple._10)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9), jring.plus(lTuple._10, rTuple._10)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9), jring.minus(lTuple._10, rTuple._10)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9), jring.times(lTuple._10, rTuple._10)) }
}
/**
 * Combine 11 semigroups into a product semigroup
 */
class Product11HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K](apply: (A, B, C, D, E, F, G, H, I, J, K) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9), jsemigroup.plus(lTuple._10, rTuple._10), ksemigroup.plus(lTuple._11, rTuple._11)) }
}

/**
 * Combine 11 monoids into a product monoid
 */
class Product11HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K](apply: (A, B, C, D, E, F, G, H, I, J, K) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero, jmonoid.zero, kmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9), jmonoid.plus(lTuple._10, rTuple._10), kmonoid.plus(lTuple._11, rTuple._11)) }
}

/**
 * Combine 11 groups into a product group
 */
class Product11Group[X, A, B, C, D, E, F, G, H, I, J, K](apply: (A, B, C, D, E, F, G, H, I, J, K) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero, jgroup.zero, kgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9), jgroup.negate(tuple._10), kgroup.negate(tuple._11)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9), jgroup.plus(lTuple._10, rTuple._10), kgroup.plus(lTuple._11, rTuple._11)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9), jgroup.minus(lTuple._10, rTuple._10), kgroup.minus(lTuple._11, rTuple._11)) }
}

/**
 * Combine 11 rings into a product ring
 */
class Product11Ring[X, A, B, C, D, E, F, G, H, I, J, K](apply: (A, B, C, D, E, F, G, H, I, J, K) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero, jring.zero, kring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one, jring.one, kring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9), jring.negate(tuple._10), kring.negate(tuple._11)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9), jring.plus(lTuple._10, rTuple._10), kring.plus(lTuple._11, rTuple._11)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9), jring.minus(lTuple._10, rTuple._10), kring.minus(lTuple._11, rTuple._11)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9), jring.times(lTuple._10, rTuple._10), kring.times(lTuple._11, rTuple._11)) }
}
/**
 * Combine 12 semigroups into a product semigroup
 */
class Product12HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L](apply: (A, B, C, D, E, F, G, H, I, J, K, L) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9), jsemigroup.plus(lTuple._10, rTuple._10), ksemigroup.plus(lTuple._11, rTuple._11), lsemigroup.plus(lTuple._12, rTuple._12)) }
}

/**
 * Combine 12 monoids into a product monoid
 */
class Product12HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L](apply: (A, B, C, D, E, F, G, H, I, J, K, L) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero, jmonoid.zero, kmonoid.zero, lmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9), jmonoid.plus(lTuple._10, rTuple._10), kmonoid.plus(lTuple._11, rTuple._11), lmonoid.plus(lTuple._12, rTuple._12)) }
}

/**
 * Combine 12 groups into a product group
 */
class Product12Group[X, A, B, C, D, E, F, G, H, I, J, K, L](apply: (A, B, C, D, E, F, G, H, I, J, K, L) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero, jgroup.zero, kgroup.zero, lgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9), jgroup.negate(tuple._10), kgroup.negate(tuple._11), lgroup.negate(tuple._12)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9), jgroup.plus(lTuple._10, rTuple._10), kgroup.plus(lTuple._11, rTuple._11), lgroup.plus(lTuple._12, rTuple._12)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9), jgroup.minus(lTuple._10, rTuple._10), kgroup.minus(lTuple._11, rTuple._11), lgroup.minus(lTuple._12, rTuple._12)) }
}

/**
 * Combine 12 rings into a product ring
 */
class Product12Ring[X, A, B, C, D, E, F, G, H, I, J, K, L](apply: (A, B, C, D, E, F, G, H, I, J, K, L) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero, jring.zero, kring.zero, lring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one, jring.one, kring.one, lring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9), jring.negate(tuple._10), kring.negate(tuple._11), lring.negate(tuple._12)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9), jring.plus(lTuple._10, rTuple._10), kring.plus(lTuple._11, rTuple._11), lring.plus(lTuple._12, rTuple._12)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9), jring.minus(lTuple._10, rTuple._10), kring.minus(lTuple._11, rTuple._11), lring.minus(lTuple._12, rTuple._12)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9), jring.times(lTuple._10, rTuple._10), kring.times(lTuple._11, rTuple._11), lring.times(lTuple._12, rTuple._12)) }
}
/**
 * Combine 13 semigroups into a product semigroup
 */
class Product13HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9), jsemigroup.plus(lTuple._10, rTuple._10), ksemigroup.plus(lTuple._11, rTuple._11), lsemigroup.plus(lTuple._12, rTuple._12), msemigroup.plus(lTuple._13, rTuple._13)) }
}

/**
 * Combine 13 monoids into a product monoid
 */
class Product13HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero, jmonoid.zero, kmonoid.zero, lmonoid.zero, mmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9), jmonoid.plus(lTuple._10, rTuple._10), kmonoid.plus(lTuple._11, rTuple._11), lmonoid.plus(lTuple._12, rTuple._12), mmonoid.plus(lTuple._13, rTuple._13)) }
}

/**
 * Combine 13 groups into a product group
 */
class Product13Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero, jgroup.zero, kgroup.zero, lgroup.zero, mgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9), jgroup.negate(tuple._10), kgroup.negate(tuple._11), lgroup.negate(tuple._12), mgroup.negate(tuple._13)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9), jgroup.plus(lTuple._10, rTuple._10), kgroup.plus(lTuple._11, rTuple._11), lgroup.plus(lTuple._12, rTuple._12), mgroup.plus(lTuple._13, rTuple._13)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9), jgroup.minus(lTuple._10, rTuple._10), kgroup.minus(lTuple._11, rTuple._11), lgroup.minus(lTuple._12, rTuple._12), mgroup.minus(lTuple._13, rTuple._13)) }
}

/**
 * Combine 13 rings into a product ring
 */
class Product13Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero, jring.zero, kring.zero, lring.zero, mring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one, jring.one, kring.one, lring.one, mring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9), jring.negate(tuple._10), kring.negate(tuple._11), lring.negate(tuple._12), mring.negate(tuple._13)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9), jring.plus(lTuple._10, rTuple._10), kring.plus(lTuple._11, rTuple._11), lring.plus(lTuple._12, rTuple._12), mring.plus(lTuple._13, rTuple._13)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9), jring.minus(lTuple._10, rTuple._10), kring.minus(lTuple._11, rTuple._11), lring.minus(lTuple._12, rTuple._12), mring.minus(lTuple._13, rTuple._13)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9), jring.times(lTuple._10, rTuple._10), kring.times(lTuple._11, rTuple._11), lring.times(lTuple._12, rTuple._12), mring.times(lTuple._13, rTuple._13)) }
}
/**
 * Combine 14 semigroups into a product semigroup
 */
class Product14HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9), jsemigroup.plus(lTuple._10, rTuple._10), ksemigroup.plus(lTuple._11, rTuple._11), lsemigroup.plus(lTuple._12, rTuple._12), msemigroup.plus(lTuple._13, rTuple._13), nsemigroup.plus(lTuple._14, rTuple._14)) }
}

/**
 * Combine 14 monoids into a product monoid
 */
class Product14HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero, jmonoid.zero, kmonoid.zero, lmonoid.zero, mmonoid.zero, nmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9), jmonoid.plus(lTuple._10, rTuple._10), kmonoid.plus(lTuple._11, rTuple._11), lmonoid.plus(lTuple._12, rTuple._12), mmonoid.plus(lTuple._13, rTuple._13), nmonoid.plus(lTuple._14, rTuple._14)) }
}

/**
 * Combine 14 groups into a product group
 */
class Product14Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero, jgroup.zero, kgroup.zero, lgroup.zero, mgroup.zero, ngroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9), jgroup.negate(tuple._10), kgroup.negate(tuple._11), lgroup.negate(tuple._12), mgroup.negate(tuple._13), ngroup.negate(tuple._14)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9), jgroup.plus(lTuple._10, rTuple._10), kgroup.plus(lTuple._11, rTuple._11), lgroup.plus(lTuple._12, rTuple._12), mgroup.plus(lTuple._13, rTuple._13), ngroup.plus(lTuple._14, rTuple._14)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9), jgroup.minus(lTuple._10, rTuple._10), kgroup.minus(lTuple._11, rTuple._11), lgroup.minus(lTuple._12, rTuple._12), mgroup.minus(lTuple._13, rTuple._13), ngroup.minus(lTuple._14, rTuple._14)) }
}

/**
 * Combine 14 rings into a product ring
 */
class Product14Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero, jring.zero, kring.zero, lring.zero, mring.zero, nring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one, jring.one, kring.one, lring.one, mring.one, nring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9), jring.negate(tuple._10), kring.negate(tuple._11), lring.negate(tuple._12), mring.negate(tuple._13), nring.negate(tuple._14)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9), jring.plus(lTuple._10, rTuple._10), kring.plus(lTuple._11, rTuple._11), lring.plus(lTuple._12, rTuple._12), mring.plus(lTuple._13, rTuple._13), nring.plus(lTuple._14, rTuple._14)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9), jring.minus(lTuple._10, rTuple._10), kring.minus(lTuple._11, rTuple._11), lring.minus(lTuple._12, rTuple._12), mring.minus(lTuple._13, rTuple._13), nring.minus(lTuple._14, rTuple._14)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9), jring.times(lTuple._10, rTuple._10), kring.times(lTuple._11, rTuple._11), lring.times(lTuple._12, rTuple._12), mring.times(lTuple._13, rTuple._13), nring.times(lTuple._14, rTuple._14)) }
}
/**
 * Combine 15 semigroups into a product semigroup
 */
class Product15HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9), jsemigroup.plus(lTuple._10, rTuple._10), ksemigroup.plus(lTuple._11, rTuple._11), lsemigroup.plus(lTuple._12, rTuple._12), msemigroup.plus(lTuple._13, rTuple._13), nsemigroup.plus(lTuple._14, rTuple._14), osemigroup.plus(lTuple._15, rTuple._15)) }
}

/**
 * Combine 15 monoids into a product monoid
 */
class Product15HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero, jmonoid.zero, kmonoid.zero, lmonoid.zero, mmonoid.zero, nmonoid.zero, omonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9), jmonoid.plus(lTuple._10, rTuple._10), kmonoid.plus(lTuple._11, rTuple._11), lmonoid.plus(lTuple._12, rTuple._12), mmonoid.plus(lTuple._13, rTuple._13), nmonoid.plus(lTuple._14, rTuple._14), omonoid.plus(lTuple._15, rTuple._15)) }
}

/**
 * Combine 15 groups into a product group
 */
class Product15Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero, jgroup.zero, kgroup.zero, lgroup.zero, mgroup.zero, ngroup.zero, ogroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9), jgroup.negate(tuple._10), kgroup.negate(tuple._11), lgroup.negate(tuple._12), mgroup.negate(tuple._13), ngroup.negate(tuple._14), ogroup.negate(tuple._15)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9), jgroup.plus(lTuple._10, rTuple._10), kgroup.plus(lTuple._11, rTuple._11), lgroup.plus(lTuple._12, rTuple._12), mgroup.plus(lTuple._13, rTuple._13), ngroup.plus(lTuple._14, rTuple._14), ogroup.plus(lTuple._15, rTuple._15)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9), jgroup.minus(lTuple._10, rTuple._10), kgroup.minus(lTuple._11, rTuple._11), lgroup.minus(lTuple._12, rTuple._12), mgroup.minus(lTuple._13, rTuple._13), ngroup.minus(lTuple._14, rTuple._14), ogroup.minus(lTuple._15, rTuple._15)) }
}

/**
 * Combine 15 rings into a product ring
 */
class Product15Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero, jring.zero, kring.zero, lring.zero, mring.zero, nring.zero, oring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one, jring.one, kring.one, lring.one, mring.one, nring.one, oring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9), jring.negate(tuple._10), kring.negate(tuple._11), lring.negate(tuple._12), mring.negate(tuple._13), nring.negate(tuple._14), oring.negate(tuple._15)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9), jring.plus(lTuple._10, rTuple._10), kring.plus(lTuple._11, rTuple._11), lring.plus(lTuple._12, rTuple._12), mring.plus(lTuple._13, rTuple._13), nring.plus(lTuple._14, rTuple._14), oring.plus(lTuple._15, rTuple._15)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9), jring.minus(lTuple._10, rTuple._10), kring.minus(lTuple._11, rTuple._11), lring.minus(lTuple._12, rTuple._12), mring.minus(lTuple._13, rTuple._13), nring.minus(lTuple._14, rTuple._14), oring.minus(lTuple._15, rTuple._15)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9), jring.times(lTuple._10, rTuple._10), kring.times(lTuple._11, rTuple._11), lring.times(lTuple._12, rTuple._12), mring.times(lTuple._13, rTuple._13), nring.times(lTuple._14, rTuple._14), oring.times(lTuple._15, rTuple._15)) }
}
/**
 * Combine 16 semigroups into a product semigroup
 */
class Product16HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9), jsemigroup.plus(lTuple._10, rTuple._10), ksemigroup.plus(lTuple._11, rTuple._11), lsemigroup.plus(lTuple._12, rTuple._12), msemigroup.plus(lTuple._13, rTuple._13), nsemigroup.plus(lTuple._14, rTuple._14), osemigroup.plus(lTuple._15, rTuple._15), psemigroup.plus(lTuple._16, rTuple._16)) }
}

/**
 * Combine 16 monoids into a product monoid
 */
class Product16HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero, jmonoid.zero, kmonoid.zero, lmonoid.zero, mmonoid.zero, nmonoid.zero, omonoid.zero, pmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9), jmonoid.plus(lTuple._10, rTuple._10), kmonoid.plus(lTuple._11, rTuple._11), lmonoid.plus(lTuple._12, rTuple._12), mmonoid.plus(lTuple._13, rTuple._13), nmonoid.plus(lTuple._14, rTuple._14), omonoid.plus(lTuple._15, rTuple._15), pmonoid.plus(lTuple._16, rTuple._16)) }
}

/**
 * Combine 16 groups into a product group
 */
class Product16Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero, jgroup.zero, kgroup.zero, lgroup.zero, mgroup.zero, ngroup.zero, ogroup.zero, pgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9), jgroup.negate(tuple._10), kgroup.negate(tuple._11), lgroup.negate(tuple._12), mgroup.negate(tuple._13), ngroup.negate(tuple._14), ogroup.negate(tuple._15), pgroup.negate(tuple._16)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9), jgroup.plus(lTuple._10, rTuple._10), kgroup.plus(lTuple._11, rTuple._11), lgroup.plus(lTuple._12, rTuple._12), mgroup.plus(lTuple._13, rTuple._13), ngroup.plus(lTuple._14, rTuple._14), ogroup.plus(lTuple._15, rTuple._15), pgroup.plus(lTuple._16, rTuple._16)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9), jgroup.minus(lTuple._10, rTuple._10), kgroup.minus(lTuple._11, rTuple._11), lgroup.minus(lTuple._12, rTuple._12), mgroup.minus(lTuple._13, rTuple._13), ngroup.minus(lTuple._14, rTuple._14), ogroup.minus(lTuple._15, rTuple._15), pgroup.minus(lTuple._16, rTuple._16)) }
}

/**
 * Combine 16 rings into a product ring
 */
class Product16Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero, jring.zero, kring.zero, lring.zero, mring.zero, nring.zero, oring.zero, pring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one, jring.one, kring.one, lring.one, mring.one, nring.one, oring.one, pring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9), jring.negate(tuple._10), kring.negate(tuple._11), lring.negate(tuple._12), mring.negate(tuple._13), nring.negate(tuple._14), oring.negate(tuple._15), pring.negate(tuple._16)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9), jring.plus(lTuple._10, rTuple._10), kring.plus(lTuple._11, rTuple._11), lring.plus(lTuple._12, rTuple._12), mring.plus(lTuple._13, rTuple._13), nring.plus(lTuple._14, rTuple._14), oring.plus(lTuple._15, rTuple._15), pring.plus(lTuple._16, rTuple._16)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9), jring.minus(lTuple._10, rTuple._10), kring.minus(lTuple._11, rTuple._11), lring.minus(lTuple._12, rTuple._12), mring.minus(lTuple._13, rTuple._13), nring.minus(lTuple._14, rTuple._14), oring.minus(lTuple._15, rTuple._15), pring.minus(lTuple._16, rTuple._16)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9), jring.times(lTuple._10, rTuple._10), kring.times(lTuple._11, rTuple._11), lring.times(lTuple._12, rTuple._12), mring.times(lTuple._13, rTuple._13), nring.times(lTuple._14, rTuple._14), oring.times(lTuple._15, rTuple._15), pring.times(lTuple._16, rTuple._16)) }
}
/**
 * Combine 17 semigroups into a product semigroup
 */
class Product17HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P], qsemigroup: HasAdditionOperator[Q]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9), jsemigroup.plus(lTuple._10, rTuple._10), ksemigroup.plus(lTuple._11, rTuple._11), lsemigroup.plus(lTuple._12, rTuple._12), msemigroup.plus(lTuple._13, rTuple._13), nsemigroup.plus(lTuple._14, rTuple._14), osemigroup.plus(lTuple._15, rTuple._15), psemigroup.plus(lTuple._16, rTuple._16), qsemigroup.plus(lTuple._17, rTuple._17)) }
}

/**
 * Combine 17 monoids into a product monoid
 */
class Product17HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P], qmonoid: HasAdditionOperatorAndZero[Q]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero, jmonoid.zero, kmonoid.zero, lmonoid.zero, mmonoid.zero, nmonoid.zero, omonoid.zero, pmonoid.zero, qmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9), jmonoid.plus(lTuple._10, rTuple._10), kmonoid.plus(lTuple._11, rTuple._11), lmonoid.plus(lTuple._12, rTuple._12), mmonoid.plus(lTuple._13, rTuple._13), nmonoid.plus(lTuple._14, rTuple._14), omonoid.plus(lTuple._15, rTuple._15), pmonoid.plus(lTuple._16, rTuple._16), qmonoid.plus(lTuple._17, rTuple._17)) }
}

/**
 * Combine 17 groups into a product group
 */
class Product17Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P], qgroup: Group[Q]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero, jgroup.zero, kgroup.zero, lgroup.zero, mgroup.zero, ngroup.zero, ogroup.zero, pgroup.zero, qgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9), jgroup.negate(tuple._10), kgroup.negate(tuple._11), lgroup.negate(tuple._12), mgroup.negate(tuple._13), ngroup.negate(tuple._14), ogroup.negate(tuple._15), pgroup.negate(tuple._16), qgroup.negate(tuple._17)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9), jgroup.plus(lTuple._10, rTuple._10), kgroup.plus(lTuple._11, rTuple._11), lgroup.plus(lTuple._12, rTuple._12), mgroup.plus(lTuple._13, rTuple._13), ngroup.plus(lTuple._14, rTuple._14), ogroup.plus(lTuple._15, rTuple._15), pgroup.plus(lTuple._16, rTuple._16), qgroup.plus(lTuple._17, rTuple._17)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9), jgroup.minus(lTuple._10, rTuple._10), kgroup.minus(lTuple._11, rTuple._11), lgroup.minus(lTuple._12, rTuple._12), mgroup.minus(lTuple._13, rTuple._13), ngroup.minus(lTuple._14, rTuple._14), ogroup.minus(lTuple._15, rTuple._15), pgroup.minus(lTuple._16, rTuple._16), qgroup.minus(lTuple._17, rTuple._17)) }
}

/**
 * Combine 17 rings into a product ring
 */
class Product17Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P], qring: Ring[Q]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero, jring.zero, kring.zero, lring.zero, mring.zero, nring.zero, oring.zero, pring.zero, qring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one, jring.one, kring.one, lring.one, mring.one, nring.one, oring.one, pring.one, qring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9), jring.negate(tuple._10), kring.negate(tuple._11), lring.negate(tuple._12), mring.negate(tuple._13), nring.negate(tuple._14), oring.negate(tuple._15), pring.negate(tuple._16), qring.negate(tuple._17)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9), jring.plus(lTuple._10, rTuple._10), kring.plus(lTuple._11, rTuple._11), lring.plus(lTuple._12, rTuple._12), mring.plus(lTuple._13, rTuple._13), nring.plus(lTuple._14, rTuple._14), oring.plus(lTuple._15, rTuple._15), pring.plus(lTuple._16, rTuple._16), qring.plus(lTuple._17, rTuple._17)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9), jring.minus(lTuple._10, rTuple._10), kring.minus(lTuple._11, rTuple._11), lring.minus(lTuple._12, rTuple._12), mring.minus(lTuple._13, rTuple._13), nring.minus(lTuple._14, rTuple._14), oring.minus(lTuple._15, rTuple._15), pring.minus(lTuple._16, rTuple._16), qring.minus(lTuple._17, rTuple._17)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9), jring.times(lTuple._10, rTuple._10), kring.times(lTuple._11, rTuple._11), lring.times(lTuple._12, rTuple._12), mring.times(lTuple._13, rTuple._13), nring.times(lTuple._14, rTuple._14), oring.times(lTuple._15, rTuple._15), pring.times(lTuple._16, rTuple._16), qring.times(lTuple._17, rTuple._17)) }
}
/**
 * Combine 18 semigroups into a product semigroup
 */
class Product18HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P], qsemigroup: HasAdditionOperator[Q], rsemigroup: HasAdditionOperator[R]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9), jsemigroup.plus(lTuple._10, rTuple._10), ksemigroup.plus(lTuple._11, rTuple._11), lsemigroup.plus(lTuple._12, rTuple._12), msemigroup.plus(lTuple._13, rTuple._13), nsemigroup.plus(lTuple._14, rTuple._14), osemigroup.plus(lTuple._15, rTuple._15), psemigroup.plus(lTuple._16, rTuple._16), qsemigroup.plus(lTuple._17, rTuple._17), rsemigroup.plus(lTuple._18, rTuple._18)) }
}

/**
 * Combine 18 monoids into a product monoid
 */
class Product18HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P], qmonoid: HasAdditionOperatorAndZero[Q], rmonoid: HasAdditionOperatorAndZero[R]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero, jmonoid.zero, kmonoid.zero, lmonoid.zero, mmonoid.zero, nmonoid.zero, omonoid.zero, pmonoid.zero, qmonoid.zero, rmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9), jmonoid.plus(lTuple._10, rTuple._10), kmonoid.plus(lTuple._11, rTuple._11), lmonoid.plus(lTuple._12, rTuple._12), mmonoid.plus(lTuple._13, rTuple._13), nmonoid.plus(lTuple._14, rTuple._14), omonoid.plus(lTuple._15, rTuple._15), pmonoid.plus(lTuple._16, rTuple._16), qmonoid.plus(lTuple._17, rTuple._17), rmonoid.plus(lTuple._18, rTuple._18)) }
}

/**
 * Combine 18 groups into a product group
 */
class Product18Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P], qgroup: Group[Q], rgroup: Group[R]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero, jgroup.zero, kgroup.zero, lgroup.zero, mgroup.zero, ngroup.zero, ogroup.zero, pgroup.zero, qgroup.zero, rgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9), jgroup.negate(tuple._10), kgroup.negate(tuple._11), lgroup.negate(tuple._12), mgroup.negate(tuple._13), ngroup.negate(tuple._14), ogroup.negate(tuple._15), pgroup.negate(tuple._16), qgroup.negate(tuple._17), rgroup.negate(tuple._18)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9), jgroup.plus(lTuple._10, rTuple._10), kgroup.plus(lTuple._11, rTuple._11), lgroup.plus(lTuple._12, rTuple._12), mgroup.plus(lTuple._13, rTuple._13), ngroup.plus(lTuple._14, rTuple._14), ogroup.plus(lTuple._15, rTuple._15), pgroup.plus(lTuple._16, rTuple._16), qgroup.plus(lTuple._17, rTuple._17), rgroup.plus(lTuple._18, rTuple._18)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9), jgroup.minus(lTuple._10, rTuple._10), kgroup.minus(lTuple._11, rTuple._11), lgroup.minus(lTuple._12, rTuple._12), mgroup.minus(lTuple._13, rTuple._13), ngroup.minus(lTuple._14, rTuple._14), ogroup.minus(lTuple._15, rTuple._15), pgroup.minus(lTuple._16, rTuple._16), qgroup.minus(lTuple._17, rTuple._17), rgroup.minus(lTuple._18, rTuple._18)) }
}

/**
 * Combine 18 rings into a product ring
 */
class Product18Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P], qring: Ring[Q], rring: Ring[R]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero, jring.zero, kring.zero, lring.zero, mring.zero, nring.zero, oring.zero, pring.zero, qring.zero, rring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one, jring.one, kring.one, lring.one, mring.one, nring.one, oring.one, pring.one, qring.one, rring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9), jring.negate(tuple._10), kring.negate(tuple._11), lring.negate(tuple._12), mring.negate(tuple._13), nring.negate(tuple._14), oring.negate(tuple._15), pring.negate(tuple._16), qring.negate(tuple._17), rring.negate(tuple._18)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9), jring.plus(lTuple._10, rTuple._10), kring.plus(lTuple._11, rTuple._11), lring.plus(lTuple._12, rTuple._12), mring.plus(lTuple._13, rTuple._13), nring.plus(lTuple._14, rTuple._14), oring.plus(lTuple._15, rTuple._15), pring.plus(lTuple._16, rTuple._16), qring.plus(lTuple._17, rTuple._17), rring.plus(lTuple._18, rTuple._18)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9), jring.minus(lTuple._10, rTuple._10), kring.minus(lTuple._11, rTuple._11), lring.minus(lTuple._12, rTuple._12), mring.minus(lTuple._13, rTuple._13), nring.minus(lTuple._14, rTuple._14), oring.minus(lTuple._15, rTuple._15), pring.minus(lTuple._16, rTuple._16), qring.minus(lTuple._17, rTuple._17), rring.minus(lTuple._18, rTuple._18)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9), jring.times(lTuple._10, rTuple._10), kring.times(lTuple._11, rTuple._11), lring.times(lTuple._12, rTuple._12), mring.times(lTuple._13, rTuple._13), nring.times(lTuple._14, rTuple._14), oring.times(lTuple._15, rTuple._15), pring.times(lTuple._16, rTuple._16), qring.times(lTuple._17, rTuple._17), rring.times(lTuple._18, rTuple._18)) }
}
/**
 * Combine 19 semigroups into a product semigroup
 */
class Product19HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P], qsemigroup: HasAdditionOperator[Q], rsemigroup: HasAdditionOperator[R], ssemigroup: HasAdditionOperator[S]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9), jsemigroup.plus(lTuple._10, rTuple._10), ksemigroup.plus(lTuple._11, rTuple._11), lsemigroup.plus(lTuple._12, rTuple._12), msemigroup.plus(lTuple._13, rTuple._13), nsemigroup.plus(lTuple._14, rTuple._14), osemigroup.plus(lTuple._15, rTuple._15), psemigroup.plus(lTuple._16, rTuple._16), qsemigroup.plus(lTuple._17, rTuple._17), rsemigroup.plus(lTuple._18, rTuple._18), ssemigroup.plus(lTuple._19, rTuple._19)) }
}

/**
 * Combine 19 monoids into a product monoid
 */
class Product19HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P], qmonoid: HasAdditionOperatorAndZero[Q], rmonoid: HasAdditionOperatorAndZero[R], smonoid: HasAdditionOperatorAndZero[S]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero, jmonoid.zero, kmonoid.zero, lmonoid.zero, mmonoid.zero, nmonoid.zero, omonoid.zero, pmonoid.zero, qmonoid.zero, rmonoid.zero, smonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9), jmonoid.plus(lTuple._10, rTuple._10), kmonoid.plus(lTuple._11, rTuple._11), lmonoid.plus(lTuple._12, rTuple._12), mmonoid.plus(lTuple._13, rTuple._13), nmonoid.plus(lTuple._14, rTuple._14), omonoid.plus(lTuple._15, rTuple._15), pmonoid.plus(lTuple._16, rTuple._16), qmonoid.plus(lTuple._17, rTuple._17), rmonoid.plus(lTuple._18, rTuple._18), smonoid.plus(lTuple._19, rTuple._19)) }
}

/**
 * Combine 19 groups into a product group
 */
class Product19Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P], qgroup: Group[Q], rgroup: Group[R], sgroup: Group[S]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero, jgroup.zero, kgroup.zero, lgroup.zero, mgroup.zero, ngroup.zero, ogroup.zero, pgroup.zero, qgroup.zero, rgroup.zero, sgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9), jgroup.negate(tuple._10), kgroup.negate(tuple._11), lgroup.negate(tuple._12), mgroup.negate(tuple._13), ngroup.negate(tuple._14), ogroup.negate(tuple._15), pgroup.negate(tuple._16), qgroup.negate(tuple._17), rgroup.negate(tuple._18), sgroup.negate(tuple._19)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9), jgroup.plus(lTuple._10, rTuple._10), kgroup.plus(lTuple._11, rTuple._11), lgroup.plus(lTuple._12, rTuple._12), mgroup.plus(lTuple._13, rTuple._13), ngroup.plus(lTuple._14, rTuple._14), ogroup.plus(lTuple._15, rTuple._15), pgroup.plus(lTuple._16, rTuple._16), qgroup.plus(lTuple._17, rTuple._17), rgroup.plus(lTuple._18, rTuple._18), sgroup.plus(lTuple._19, rTuple._19)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9), jgroup.minus(lTuple._10, rTuple._10), kgroup.minus(lTuple._11, rTuple._11), lgroup.minus(lTuple._12, rTuple._12), mgroup.minus(lTuple._13, rTuple._13), ngroup.minus(lTuple._14, rTuple._14), ogroup.minus(lTuple._15, rTuple._15), pgroup.minus(lTuple._16, rTuple._16), qgroup.minus(lTuple._17, rTuple._17), rgroup.minus(lTuple._18, rTuple._18), sgroup.minus(lTuple._19, rTuple._19)) }
}

/**
 * Combine 19 rings into a product ring
 */
class Product19Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P], qring: Ring[Q], rring: Ring[R], sring: Ring[S]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero, jring.zero, kring.zero, lring.zero, mring.zero, nring.zero, oring.zero, pring.zero, qring.zero, rring.zero, sring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one, jring.one, kring.one, lring.one, mring.one, nring.one, oring.one, pring.one, qring.one, rring.one, sring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9), jring.negate(tuple._10), kring.negate(tuple._11), lring.negate(tuple._12), mring.negate(tuple._13), nring.negate(tuple._14), oring.negate(tuple._15), pring.negate(tuple._16), qring.negate(tuple._17), rring.negate(tuple._18), sring.negate(tuple._19)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9), jring.plus(lTuple._10, rTuple._10), kring.plus(lTuple._11, rTuple._11), lring.plus(lTuple._12, rTuple._12), mring.plus(lTuple._13, rTuple._13), nring.plus(lTuple._14, rTuple._14), oring.plus(lTuple._15, rTuple._15), pring.plus(lTuple._16, rTuple._16), qring.plus(lTuple._17, rTuple._17), rring.plus(lTuple._18, rTuple._18), sring.plus(lTuple._19, rTuple._19)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9), jring.minus(lTuple._10, rTuple._10), kring.minus(lTuple._11, rTuple._11), lring.minus(lTuple._12, rTuple._12), mring.minus(lTuple._13, rTuple._13), nring.minus(lTuple._14, rTuple._14), oring.minus(lTuple._15, rTuple._15), pring.minus(lTuple._16, rTuple._16), qring.minus(lTuple._17, rTuple._17), rring.minus(lTuple._18, rTuple._18), sring.minus(lTuple._19, rTuple._19)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9), jring.times(lTuple._10, rTuple._10), kring.times(lTuple._11, rTuple._11), lring.times(lTuple._12, rTuple._12), mring.times(lTuple._13, rTuple._13), nring.times(lTuple._14, rTuple._14), oring.times(lTuple._15, rTuple._15), pring.times(lTuple._16, rTuple._16), qring.times(lTuple._17, rTuple._17), rring.times(lTuple._18, rTuple._18), sring.times(lTuple._19, rTuple._19)) }
}
/**
 * Combine 20 semigroups into a product semigroup
 */
class Product20HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P], qsemigroup: HasAdditionOperator[Q], rsemigroup: HasAdditionOperator[R], ssemigroup: HasAdditionOperator[S], tsemigroup: HasAdditionOperator[T]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9), jsemigroup.plus(lTuple._10, rTuple._10), ksemigroup.plus(lTuple._11, rTuple._11), lsemigroup.plus(lTuple._12, rTuple._12), msemigroup.plus(lTuple._13, rTuple._13), nsemigroup.plus(lTuple._14, rTuple._14), osemigroup.plus(lTuple._15, rTuple._15), psemigroup.plus(lTuple._16, rTuple._16), qsemigroup.plus(lTuple._17, rTuple._17), rsemigroup.plus(lTuple._18, rTuple._18), ssemigroup.plus(lTuple._19, rTuple._19), tsemigroup.plus(lTuple._20, rTuple._20)) }
}

/**
 * Combine 20 monoids into a product monoid
 */
class Product20HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P], qmonoid: HasAdditionOperatorAndZero[Q], rmonoid: HasAdditionOperatorAndZero[R], smonoid: HasAdditionOperatorAndZero[S], tmonoid: HasAdditionOperatorAndZero[T]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero, jmonoid.zero, kmonoid.zero, lmonoid.zero, mmonoid.zero, nmonoid.zero, omonoid.zero, pmonoid.zero, qmonoid.zero, rmonoid.zero, smonoid.zero, tmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9), jmonoid.plus(lTuple._10, rTuple._10), kmonoid.plus(lTuple._11, rTuple._11), lmonoid.plus(lTuple._12, rTuple._12), mmonoid.plus(lTuple._13, rTuple._13), nmonoid.plus(lTuple._14, rTuple._14), omonoid.plus(lTuple._15, rTuple._15), pmonoid.plus(lTuple._16, rTuple._16), qmonoid.plus(lTuple._17, rTuple._17), rmonoid.plus(lTuple._18, rTuple._18), smonoid.plus(lTuple._19, rTuple._19), tmonoid.plus(lTuple._20, rTuple._20)) }
}

/**
 * Combine 20 groups into a product group
 */
class Product20Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P], qgroup: Group[Q], rgroup: Group[R], sgroup: Group[S], tgroup: Group[T]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero, jgroup.zero, kgroup.zero, lgroup.zero, mgroup.zero, ngroup.zero, ogroup.zero, pgroup.zero, qgroup.zero, rgroup.zero, sgroup.zero, tgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9), jgroup.negate(tuple._10), kgroup.negate(tuple._11), lgroup.negate(tuple._12), mgroup.negate(tuple._13), ngroup.negate(tuple._14), ogroup.negate(tuple._15), pgroup.negate(tuple._16), qgroup.negate(tuple._17), rgroup.negate(tuple._18), sgroup.negate(tuple._19), tgroup.negate(tuple._20)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9), jgroup.plus(lTuple._10, rTuple._10), kgroup.plus(lTuple._11, rTuple._11), lgroup.plus(lTuple._12, rTuple._12), mgroup.plus(lTuple._13, rTuple._13), ngroup.plus(lTuple._14, rTuple._14), ogroup.plus(lTuple._15, rTuple._15), pgroup.plus(lTuple._16, rTuple._16), qgroup.plus(lTuple._17, rTuple._17), rgroup.plus(lTuple._18, rTuple._18), sgroup.plus(lTuple._19, rTuple._19), tgroup.plus(lTuple._20, rTuple._20)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9), jgroup.minus(lTuple._10, rTuple._10), kgroup.minus(lTuple._11, rTuple._11), lgroup.minus(lTuple._12, rTuple._12), mgroup.minus(lTuple._13, rTuple._13), ngroup.minus(lTuple._14, rTuple._14), ogroup.minus(lTuple._15, rTuple._15), pgroup.minus(lTuple._16, rTuple._16), qgroup.minus(lTuple._17, rTuple._17), rgroup.minus(lTuple._18, rTuple._18), sgroup.minus(lTuple._19, rTuple._19), tgroup.minus(lTuple._20, rTuple._20)) }
}

/**
 * Combine 20 rings into a product ring
 */
class Product20Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P], qring: Ring[Q], rring: Ring[R], sring: Ring[S], tring: Ring[T]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero, jring.zero, kring.zero, lring.zero, mring.zero, nring.zero, oring.zero, pring.zero, qring.zero, rring.zero, sring.zero, tring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one, jring.one, kring.one, lring.one, mring.one, nring.one, oring.one, pring.one, qring.one, rring.one, sring.one, tring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9), jring.negate(tuple._10), kring.negate(tuple._11), lring.negate(tuple._12), mring.negate(tuple._13), nring.negate(tuple._14), oring.negate(tuple._15), pring.negate(tuple._16), qring.negate(tuple._17), rring.negate(tuple._18), sring.negate(tuple._19), tring.negate(tuple._20)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9), jring.plus(lTuple._10, rTuple._10), kring.plus(lTuple._11, rTuple._11), lring.plus(lTuple._12, rTuple._12), mring.plus(lTuple._13, rTuple._13), nring.plus(lTuple._14, rTuple._14), oring.plus(lTuple._15, rTuple._15), pring.plus(lTuple._16, rTuple._16), qring.plus(lTuple._17, rTuple._17), rring.plus(lTuple._18, rTuple._18), sring.plus(lTuple._19, rTuple._19), tring.plus(lTuple._20, rTuple._20)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9), jring.minus(lTuple._10, rTuple._10), kring.minus(lTuple._11, rTuple._11), lring.minus(lTuple._12, rTuple._12), mring.minus(lTuple._13, rTuple._13), nring.minus(lTuple._14, rTuple._14), oring.minus(lTuple._15, rTuple._15), pring.minus(lTuple._16, rTuple._16), qring.minus(lTuple._17, rTuple._17), rring.minus(lTuple._18, rTuple._18), sring.minus(lTuple._19, rTuple._19), tring.minus(lTuple._20, rTuple._20)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9), jring.times(lTuple._10, rTuple._10), kring.times(lTuple._11, rTuple._11), lring.times(lTuple._12, rTuple._12), mring.times(lTuple._13, rTuple._13), nring.times(lTuple._14, rTuple._14), oring.times(lTuple._15, rTuple._15), pring.times(lTuple._16, rTuple._16), qring.times(lTuple._17, rTuple._17), rring.times(lTuple._18, rTuple._18), sring.times(lTuple._19, rTuple._19), tring.times(lTuple._20, rTuple._20)) }
}
/**
 * Combine 21 semigroups into a product semigroup
 */
class Product21HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P], qsemigroup: HasAdditionOperator[Q], rsemigroup: HasAdditionOperator[R], ssemigroup: HasAdditionOperator[S], tsemigroup: HasAdditionOperator[T], usemigroup: HasAdditionOperator[U]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9), jsemigroup.plus(lTuple._10, rTuple._10), ksemigroup.plus(lTuple._11, rTuple._11), lsemigroup.plus(lTuple._12, rTuple._12), msemigroup.plus(lTuple._13, rTuple._13), nsemigroup.plus(lTuple._14, rTuple._14), osemigroup.plus(lTuple._15, rTuple._15), psemigroup.plus(lTuple._16, rTuple._16), qsemigroup.plus(lTuple._17, rTuple._17), rsemigroup.plus(lTuple._18, rTuple._18), ssemigroup.plus(lTuple._19, rTuple._19), tsemigroup.plus(lTuple._20, rTuple._20), usemigroup.plus(lTuple._21, rTuple._21)) }
}

/**
 * Combine 21 monoids into a product monoid
 */
class Product21HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P], qmonoid: HasAdditionOperatorAndZero[Q], rmonoid: HasAdditionOperatorAndZero[R], smonoid: HasAdditionOperatorAndZero[S], tmonoid: HasAdditionOperatorAndZero[T], umonoid: HasAdditionOperatorAndZero[U]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero, jmonoid.zero, kmonoid.zero, lmonoid.zero, mmonoid.zero, nmonoid.zero, omonoid.zero, pmonoid.zero, qmonoid.zero, rmonoid.zero, smonoid.zero, tmonoid.zero, umonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9), jmonoid.plus(lTuple._10, rTuple._10), kmonoid.plus(lTuple._11, rTuple._11), lmonoid.plus(lTuple._12, rTuple._12), mmonoid.plus(lTuple._13, rTuple._13), nmonoid.plus(lTuple._14, rTuple._14), omonoid.plus(lTuple._15, rTuple._15), pmonoid.plus(lTuple._16, rTuple._16), qmonoid.plus(lTuple._17, rTuple._17), rmonoid.plus(lTuple._18, rTuple._18), smonoid.plus(lTuple._19, rTuple._19), tmonoid.plus(lTuple._20, rTuple._20), umonoid.plus(lTuple._21, rTuple._21)) }
}

/**
 * Combine 21 groups into a product group
 */
class Product21Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P], qgroup: Group[Q], rgroup: Group[R], sgroup: Group[S], tgroup: Group[T], ugroup: Group[U]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero, jgroup.zero, kgroup.zero, lgroup.zero, mgroup.zero, ngroup.zero, ogroup.zero, pgroup.zero, qgroup.zero, rgroup.zero, sgroup.zero, tgroup.zero, ugroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9), jgroup.negate(tuple._10), kgroup.negate(tuple._11), lgroup.negate(tuple._12), mgroup.negate(tuple._13), ngroup.negate(tuple._14), ogroup.negate(tuple._15), pgroup.negate(tuple._16), qgroup.negate(tuple._17), rgroup.negate(tuple._18), sgroup.negate(tuple._19), tgroup.negate(tuple._20), ugroup.negate(tuple._21)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9), jgroup.plus(lTuple._10, rTuple._10), kgroup.plus(lTuple._11, rTuple._11), lgroup.plus(lTuple._12, rTuple._12), mgroup.plus(lTuple._13, rTuple._13), ngroup.plus(lTuple._14, rTuple._14), ogroup.plus(lTuple._15, rTuple._15), pgroup.plus(lTuple._16, rTuple._16), qgroup.plus(lTuple._17, rTuple._17), rgroup.plus(lTuple._18, rTuple._18), sgroup.plus(lTuple._19, rTuple._19), tgroup.plus(lTuple._20, rTuple._20), ugroup.plus(lTuple._21, rTuple._21)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9), jgroup.minus(lTuple._10, rTuple._10), kgroup.minus(lTuple._11, rTuple._11), lgroup.minus(lTuple._12, rTuple._12), mgroup.minus(lTuple._13, rTuple._13), ngroup.minus(lTuple._14, rTuple._14), ogroup.minus(lTuple._15, rTuple._15), pgroup.minus(lTuple._16, rTuple._16), qgroup.minus(lTuple._17, rTuple._17), rgroup.minus(lTuple._18, rTuple._18), sgroup.minus(lTuple._19, rTuple._19), tgroup.minus(lTuple._20, rTuple._20), ugroup.minus(lTuple._21, rTuple._21)) }
}

/**
 * Combine 21 rings into a product ring
 */
class Product21Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P], qring: Ring[Q], rring: Ring[R], sring: Ring[S], tring: Ring[T], uring: Ring[U]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero, jring.zero, kring.zero, lring.zero, mring.zero, nring.zero, oring.zero, pring.zero, qring.zero, rring.zero, sring.zero, tring.zero, uring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one, jring.one, kring.one, lring.one, mring.one, nring.one, oring.one, pring.one, qring.one, rring.one, sring.one, tring.one, uring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9), jring.negate(tuple._10), kring.negate(tuple._11), lring.negate(tuple._12), mring.negate(tuple._13), nring.negate(tuple._14), oring.negate(tuple._15), pring.negate(tuple._16), qring.negate(tuple._17), rring.negate(tuple._18), sring.negate(tuple._19), tring.negate(tuple._20), uring.negate(tuple._21)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9), jring.plus(lTuple._10, rTuple._10), kring.plus(lTuple._11, rTuple._11), lring.plus(lTuple._12, rTuple._12), mring.plus(lTuple._13, rTuple._13), nring.plus(lTuple._14, rTuple._14), oring.plus(lTuple._15, rTuple._15), pring.plus(lTuple._16, rTuple._16), qring.plus(lTuple._17, rTuple._17), rring.plus(lTuple._18, rTuple._18), sring.plus(lTuple._19, rTuple._19), tring.plus(lTuple._20, rTuple._20), uring.plus(lTuple._21, rTuple._21)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9), jring.minus(lTuple._10, rTuple._10), kring.minus(lTuple._11, rTuple._11), lring.minus(lTuple._12, rTuple._12), mring.minus(lTuple._13, rTuple._13), nring.minus(lTuple._14, rTuple._14), oring.minus(lTuple._15, rTuple._15), pring.minus(lTuple._16, rTuple._16), qring.minus(lTuple._17, rTuple._17), rring.minus(lTuple._18, rTuple._18), sring.minus(lTuple._19, rTuple._19), tring.minus(lTuple._20, rTuple._20), uring.minus(lTuple._21, rTuple._21)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9), jring.times(lTuple._10, rTuple._10), kring.times(lTuple._11, rTuple._11), lring.times(lTuple._12, rTuple._12), mring.times(lTuple._13, rTuple._13), nring.times(lTuple._14, rTuple._14), oring.times(lTuple._15, rTuple._15), pring.times(lTuple._16, rTuple._16), qring.times(lTuple._17, rTuple._17), rring.times(lTuple._18, rTuple._18), sring.times(lTuple._19, rTuple._19), tring.times(lTuple._20, rTuple._20), uring.times(lTuple._21, rTuple._21)) }
}
/**
 * Combine 22 semigroups into a product semigroup
 */
class Product22HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P], qsemigroup: HasAdditionOperator[Q], rsemigroup: HasAdditionOperator[R], ssemigroup: HasAdditionOperator[S], tsemigroup: HasAdditionOperator[T], usemigroup: HasAdditionOperator[U], vsemigroup: HasAdditionOperator[V]) extends HasAdditionOperator[X] {
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(asemigroup.plus(lTuple._1, rTuple._1), bsemigroup.plus(lTuple._2, rTuple._2), csemigroup.plus(lTuple._3, rTuple._3), dsemigroup.plus(lTuple._4, rTuple._4), esemigroup.plus(lTuple._5, rTuple._5), fsemigroup.plus(lTuple._6, rTuple._6), gsemigroup.plus(lTuple._7, rTuple._7), hsemigroup.plus(lTuple._8, rTuple._8), isemigroup.plus(lTuple._9, rTuple._9), jsemigroup.plus(lTuple._10, rTuple._10), ksemigroup.plus(lTuple._11, rTuple._11), lsemigroup.plus(lTuple._12, rTuple._12), msemigroup.plus(lTuple._13, rTuple._13), nsemigroup.plus(lTuple._14, rTuple._14), osemigroup.plus(lTuple._15, rTuple._15), psemigroup.plus(lTuple._16, rTuple._16), qsemigroup.plus(lTuple._17, rTuple._17), rsemigroup.plus(lTuple._18, rTuple._18), ssemigroup.plus(lTuple._19, rTuple._19), tsemigroup.plus(lTuple._20, rTuple._20), usemigroup.plus(lTuple._21, rTuple._21), vsemigroup.plus(lTuple._22, rTuple._22)) }
}

/**
 * Combine 22 monoids into a product monoid
 */
class Product22HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P], qmonoid: HasAdditionOperatorAndZero[Q], rmonoid: HasAdditionOperatorAndZero[R], smonoid: HasAdditionOperatorAndZero[S], tmonoid: HasAdditionOperatorAndZero[T], umonoid: HasAdditionOperatorAndZero[U], vmonoid: HasAdditionOperatorAndZero[V]) extends HasAdditionOperatorAndZero[X] {
  override def zero = apply(amonoid.zero, bmonoid.zero, cmonoid.zero, dmonoid.zero, emonoid.zero, fmonoid.zero, gmonoid.zero, hmonoid.zero, imonoid.zero, jmonoid.zero, kmonoid.zero, lmonoid.zero, mmonoid.zero, nmonoid.zero, omonoid.zero, pmonoid.zero, qmonoid.zero, rmonoid.zero, smonoid.zero, tmonoid.zero, umonoid.zero, vmonoid.zero)
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(amonoid.plus(lTuple._1, rTuple._1), bmonoid.plus(lTuple._2, rTuple._2), cmonoid.plus(lTuple._3, rTuple._3), dmonoid.plus(lTuple._4, rTuple._4), emonoid.plus(lTuple._5, rTuple._5), fmonoid.plus(lTuple._6, rTuple._6), gmonoid.plus(lTuple._7, rTuple._7), hmonoid.plus(lTuple._8, rTuple._8), imonoid.plus(lTuple._9, rTuple._9), jmonoid.plus(lTuple._10, rTuple._10), kmonoid.plus(lTuple._11, rTuple._11), lmonoid.plus(lTuple._12, rTuple._12), mmonoid.plus(lTuple._13, rTuple._13), nmonoid.plus(lTuple._14, rTuple._14), omonoid.plus(lTuple._15, rTuple._15), pmonoid.plus(lTuple._16, rTuple._16), qmonoid.plus(lTuple._17, rTuple._17), rmonoid.plus(lTuple._18, rTuple._18), smonoid.plus(lTuple._19, rTuple._19), tmonoid.plus(lTuple._20, rTuple._20), umonoid.plus(lTuple._21, rTuple._21), vmonoid.plus(lTuple._22, rTuple._22)) }
}

/**
 * Combine 22 groups into a product group
 */
class Product22Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P], qgroup: Group[Q], rgroup: Group[R], sgroup: Group[S], tgroup: Group[T], ugroup: Group[U], vgroup: Group[V]) extends Group[X] {
  override def zero = apply(agroup.zero, bgroup.zero, cgroup.zero, dgroup.zero, egroup.zero, fgroup.zero, ggroup.zero, hgroup.zero, igroup.zero, jgroup.zero, kgroup.zero, lgroup.zero, mgroup.zero, ngroup.zero, ogroup.zero, pgroup.zero, qgroup.zero, rgroup.zero, sgroup.zero, tgroup.zero, ugroup.zero, vgroup.zero)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(agroup.negate(tuple._1), bgroup.negate(tuple._2), cgroup.negate(tuple._3), dgroup.negate(tuple._4), egroup.negate(tuple._5), fgroup.negate(tuple._6), ggroup.negate(tuple._7), hgroup.negate(tuple._8), igroup.negate(tuple._9), jgroup.negate(tuple._10), kgroup.negate(tuple._11), lgroup.negate(tuple._12), mgroup.negate(tuple._13), ngroup.negate(tuple._14), ogroup.negate(tuple._15), pgroup.negate(tuple._16), qgroup.negate(tuple._17), rgroup.negate(tuple._18), sgroup.negate(tuple._19), tgroup.negate(tuple._20), ugroup.negate(tuple._21), vgroup.negate(tuple._22)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.plus(lTuple._1, rTuple._1), bgroup.plus(lTuple._2, rTuple._2), cgroup.plus(lTuple._3, rTuple._3), dgroup.plus(lTuple._4, rTuple._4), egroup.plus(lTuple._5, rTuple._5), fgroup.plus(lTuple._6, rTuple._6), ggroup.plus(lTuple._7, rTuple._7), hgroup.plus(lTuple._8, rTuple._8), igroup.plus(lTuple._9, rTuple._9), jgroup.plus(lTuple._10, rTuple._10), kgroup.plus(lTuple._11, rTuple._11), lgroup.plus(lTuple._12, rTuple._12), mgroup.plus(lTuple._13, rTuple._13), ngroup.plus(lTuple._14, rTuple._14), ogroup.plus(lTuple._15, rTuple._15), pgroup.plus(lTuple._16, rTuple._16), qgroup.plus(lTuple._17, rTuple._17), rgroup.plus(lTuple._18, rTuple._18), sgroup.plus(lTuple._19, rTuple._19), tgroup.plus(lTuple._20, rTuple._20), ugroup.plus(lTuple._21, rTuple._21), vgroup.plus(lTuple._22, rTuple._22)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(agroup.minus(lTuple._1, rTuple._1), bgroup.minus(lTuple._2, rTuple._2), cgroup.minus(lTuple._3, rTuple._3), dgroup.minus(lTuple._4, rTuple._4), egroup.minus(lTuple._5, rTuple._5), fgroup.minus(lTuple._6, rTuple._6), ggroup.minus(lTuple._7, rTuple._7), hgroup.minus(lTuple._8, rTuple._8), igroup.minus(lTuple._9, rTuple._9), jgroup.minus(lTuple._10, rTuple._10), kgroup.minus(lTuple._11, rTuple._11), lgroup.minus(lTuple._12, rTuple._12), mgroup.minus(lTuple._13, rTuple._13), ngroup.minus(lTuple._14, rTuple._14), ogroup.minus(lTuple._15, rTuple._15), pgroup.minus(lTuple._16, rTuple._16), qgroup.minus(lTuple._17, rTuple._17), rgroup.minus(lTuple._18, rTuple._18), sgroup.minus(lTuple._19, rTuple._19), tgroup.minus(lTuple._20, rTuple._20), ugroup.minus(lTuple._21, rTuple._21), vgroup.minus(lTuple._22, rTuple._22)) }
}

/**
 * Combine 22 rings into a product ring
 */
class Product22Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](apply: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V) => X, unapply: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P], qring: Ring[Q], rring: Ring[R], sring: Ring[S], tring: Ring[T], uring: Ring[U], vring: Ring[V]) extends Ring[X] {
  override def zero = apply(aring.zero, bring.zero, cring.zero, dring.zero, ering.zero, fring.zero, gring.zero, hring.zero, iring.zero, jring.zero, kring.zero, lring.zero, mring.zero, nring.zero, oring.zero, pring.zero, qring.zero, rring.zero, sring.zero, tring.zero, uring.zero, vring.zero)
  override def one = apply(aring.one, bring.one, cring.one, dring.one, ering.one, fring.one, gring.one, hring.one, iring.one, jring.one, kring.one, lring.one, mring.one, nring.one, oring.one, pring.one, qring.one, rring.one, sring.one, tring.one, uring.one, vring.one)
  override def negate(v: X) = { val tuple = unapply(v).get; apply(aring.negate(tuple._1), bring.negate(tuple._2), cring.negate(tuple._3), dring.negate(tuple._4), ering.negate(tuple._5), fring.negate(tuple._6), gring.negate(tuple._7), hring.negate(tuple._8), iring.negate(tuple._9), jring.negate(tuple._10), kring.negate(tuple._11), lring.negate(tuple._12), mring.negate(tuple._13), nring.negate(tuple._14), oring.negate(tuple._15), pring.negate(tuple._16), qring.negate(tuple._17), rring.negate(tuple._18), sring.negate(tuple._19), tring.negate(tuple._20), uring.negate(tuple._21), vring.negate(tuple._22)) }
  override def plus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.plus(lTuple._1, rTuple._1), bring.plus(lTuple._2, rTuple._2), cring.plus(lTuple._3, rTuple._3), dring.plus(lTuple._4, rTuple._4), ering.plus(lTuple._5, rTuple._5), fring.plus(lTuple._6, rTuple._6), gring.plus(lTuple._7, rTuple._7), hring.plus(lTuple._8, rTuple._8), iring.plus(lTuple._9, rTuple._9), jring.plus(lTuple._10, rTuple._10), kring.plus(lTuple._11, rTuple._11), lring.plus(lTuple._12, rTuple._12), mring.plus(lTuple._13, rTuple._13), nring.plus(lTuple._14, rTuple._14), oring.plus(lTuple._15, rTuple._15), pring.plus(lTuple._16, rTuple._16), qring.plus(lTuple._17, rTuple._17), rring.plus(lTuple._18, rTuple._18), sring.plus(lTuple._19, rTuple._19), tring.plus(lTuple._20, rTuple._20), uring.plus(lTuple._21, rTuple._21), vring.plus(lTuple._22, rTuple._22)) }
  override def minus(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.minus(lTuple._1, rTuple._1), bring.minus(lTuple._2, rTuple._2), cring.minus(lTuple._3, rTuple._3), dring.minus(lTuple._4, rTuple._4), ering.minus(lTuple._5, rTuple._5), fring.minus(lTuple._6, rTuple._6), gring.minus(lTuple._7, rTuple._7), hring.minus(lTuple._8, rTuple._8), iring.minus(lTuple._9, rTuple._9), jring.minus(lTuple._10, rTuple._10), kring.minus(lTuple._11, rTuple._11), lring.minus(lTuple._12, rTuple._12), mring.minus(lTuple._13, rTuple._13), nring.minus(lTuple._14, rTuple._14), oring.minus(lTuple._15, rTuple._15), pring.minus(lTuple._16, rTuple._16), qring.minus(lTuple._17, rTuple._17), rring.minus(lTuple._18, rTuple._18), sring.minus(lTuple._19, rTuple._19), tring.minus(lTuple._20, rTuple._20), uring.minus(lTuple._21, rTuple._21), vring.minus(lTuple._22, rTuple._22)) }
  override def times(l: X, r: X) = { val lTuple = unapply(l).get; val rTuple = unapply(r).get; apply(aring.times(lTuple._1, rTuple._1), bring.times(lTuple._2, rTuple._2), cring.times(lTuple._3, rTuple._3), dring.times(lTuple._4, rTuple._4), ering.times(lTuple._5, rTuple._5), fring.times(lTuple._6, rTuple._6), gring.times(lTuple._7, rTuple._7), hring.times(lTuple._8, rTuple._8), iring.times(lTuple._9, rTuple._9), jring.times(lTuple._10, rTuple._10), kring.times(lTuple._11, rTuple._11), lring.times(lTuple._12, rTuple._12), mring.times(lTuple._13, rTuple._13), nring.times(lTuple._14, rTuple._14), oring.times(lTuple._15, rTuple._15), pring.times(lTuple._16, rTuple._16), qring.times(lTuple._17, rTuple._17), rring.times(lTuple._18, rTuple._18), sring.times(lTuple._19, rTuple._19), tring.times(lTuple._20, rTuple._20), uring.times(lTuple._21, rTuple._21), vring.times(lTuple._22, rTuple._22)) }
}

trait ProductHasAdditionOperators {
  def apply[X, A, B](applyX: (A, B) => X, unapplyX: X => Option[(A, B)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B]): HasAdditionOperator[X] = {
    new Product2HasAdditionOperator[X, A, B](applyX, unapplyX)(asemigroup, bsemigroup)
  }

  def apply[X, A, B, C](applyX: (A, B, C) => X, unapplyX: X => Option[(A, B, C)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C]): HasAdditionOperator[X] = {
    new Product3HasAdditionOperator[X, A, B, C](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup)
  }

  def apply[X, A, B, C, D](applyX: (A, B, C, D) => X, unapplyX: X => Option[(A, B, C, D)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D]): HasAdditionOperator[X] = {
    new Product4HasAdditionOperator[X, A, B, C, D](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup)
  }

  def apply[X, A, B, C, D, E](applyX: (A, B, C, D, E) => X, unapplyX: X => Option[(A, B, C, D, E)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E]): HasAdditionOperator[X] = {
    new Product5HasAdditionOperator[X, A, B, C, D, E](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup)
  }

  def apply[X, A, B, C, D, E, F](applyX: (A, B, C, D, E, F) => X, unapplyX: X => Option[(A, B, C, D, E, F)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F]): HasAdditionOperator[X] = {
    new Product6HasAdditionOperator[X, A, B, C, D, E, F](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup)
  }

  def apply[X, A, B, C, D, E, F, G](applyX: (A, B, C, D, E, F, G) => X, unapplyX: X => Option[(A, B, C, D, E, F, G)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G]): HasAdditionOperator[X] = {
    new Product7HasAdditionOperator[X, A, B, C, D, E, F, G](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H](applyX: (A, B, C, D, E, F, G, H) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H]): HasAdditionOperator[X] = {
    new Product8HasAdditionOperator[X, A, B, C, D, E, F, G, H](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I](applyX: (A, B, C, D, E, F, G, H, I) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I]): HasAdditionOperator[X] = {
    new Product9HasAdditionOperator[X, A, B, C, D, E, F, G, H, I](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J](applyX: (A, B, C, D, E, F, G, H, I, J) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J]): HasAdditionOperator[X] = {
    new Product10HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup, jsemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K](applyX: (A, B, C, D, E, F, G, H, I, J, K) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K]): HasAdditionOperator[X] = {
    new Product11HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup, jsemigroup, ksemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L](applyX: (A, B, C, D, E, F, G, H, I, J, K, L) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L]): HasAdditionOperator[X] = {
    new Product12HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup, jsemigroup, ksemigroup, lsemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M]): HasAdditionOperator[X] = {
    new Product13HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup, jsemigroup, ksemigroup, lsemigroup, msemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N]): HasAdditionOperator[X] = {
    new Product14HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup, jsemigroup, ksemigroup, lsemigroup, msemigroup, nsemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O]): HasAdditionOperator[X] = {
    new Product15HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup, jsemigroup, ksemigroup, lsemigroup, msemigroup, nsemigroup, osemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P]): HasAdditionOperator[X] = {
    new Product16HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup, jsemigroup, ksemigroup, lsemigroup, msemigroup, nsemigroup, osemigroup, psemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P], qsemigroup: HasAdditionOperator[Q]): HasAdditionOperator[X] = {
    new Product17HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup, jsemigroup, ksemigroup, lsemigroup, msemigroup, nsemigroup, osemigroup, psemigroup, qsemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P], qsemigroup: HasAdditionOperator[Q], rsemigroup: HasAdditionOperator[R]): HasAdditionOperator[X] = {
    new Product18HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup, jsemigroup, ksemigroup, lsemigroup, msemigroup, nsemigroup, osemigroup, psemigroup, qsemigroup, rsemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P], qsemigroup: HasAdditionOperator[Q], rsemigroup: HasAdditionOperator[R], ssemigroup: HasAdditionOperator[S]): HasAdditionOperator[X] = {
    new Product19HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup, jsemigroup, ksemigroup, lsemigroup, msemigroup, nsemigroup, osemigroup, psemigroup, qsemigroup, rsemigroup, ssemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P], qsemigroup: HasAdditionOperator[Q], rsemigroup: HasAdditionOperator[R], ssemigroup: HasAdditionOperator[S], tsemigroup: HasAdditionOperator[T]): HasAdditionOperator[X] = {
    new Product20HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup, jsemigroup, ksemigroup, lsemigroup, msemigroup, nsemigroup, osemigroup, psemigroup, qsemigroup, rsemigroup, ssemigroup, tsemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P], qsemigroup: HasAdditionOperator[Q], rsemigroup: HasAdditionOperator[R], ssemigroup: HasAdditionOperator[S], tsemigroup: HasAdditionOperator[T], usemigroup: HasAdditionOperator[U]): HasAdditionOperator[X] = {
    new Product21HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup, jsemigroup, ksemigroup, lsemigroup, msemigroup, nsemigroup, osemigroup, psemigroup, qsemigroup, rsemigroup, ssemigroup, tsemigroup, usemigroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)])(implicit asemigroup: HasAdditionOperator[A], bsemigroup: HasAdditionOperator[B], csemigroup: HasAdditionOperator[C], dsemigroup: HasAdditionOperator[D], esemigroup: HasAdditionOperator[E], fsemigroup: HasAdditionOperator[F], gsemigroup: HasAdditionOperator[G], hsemigroup: HasAdditionOperator[H], isemigroup: HasAdditionOperator[I], jsemigroup: HasAdditionOperator[J], ksemigroup: HasAdditionOperator[K], lsemigroup: HasAdditionOperator[L], msemigroup: HasAdditionOperator[M], nsemigroup: HasAdditionOperator[N], osemigroup: HasAdditionOperator[O], psemigroup: HasAdditionOperator[P], qsemigroup: HasAdditionOperator[Q], rsemigroup: HasAdditionOperator[R], ssemigroup: HasAdditionOperator[S], tsemigroup: HasAdditionOperator[T], usemigroup: HasAdditionOperator[U], vsemigroup: HasAdditionOperator[V]): HasAdditionOperator[X] = {
    new Product22HasAdditionOperator[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](applyX, unapplyX)(asemigroup, bsemigroup, csemigroup, dsemigroup, esemigroup, fsemigroup, gsemigroup, hsemigroup, isemigroup, jsemigroup, ksemigroup, lsemigroup, msemigroup, nsemigroup, osemigroup, psemigroup, qsemigroup, rsemigroup, ssemigroup, tsemigroup, usemigroup, vsemigroup)
  }

}

trait ProductHasAdditionOperatorAndZeros {
  def apply[X, A, B](applyX: (A, B) => X, unapplyX: X => Option[(A, B)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B]): HasAdditionOperatorAndZero[X] = {
    new Product2HasAdditionOperatorAndZero[X, A, B](applyX, unapplyX)(amonoid, bmonoid)
  }

  def apply[X, A, B, C](applyX: (A, B, C) => X, unapplyX: X => Option[(A, B, C)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C]): HasAdditionOperatorAndZero[X] = {
    new Product3HasAdditionOperatorAndZero[X, A, B, C](applyX, unapplyX)(amonoid, bmonoid, cmonoid)
  }

  def apply[X, A, B, C, D](applyX: (A, B, C, D) => X, unapplyX: X => Option[(A, B, C, D)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D]): HasAdditionOperatorAndZero[X] = {
    new Product4HasAdditionOperatorAndZero[X, A, B, C, D](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid)
  }

  def apply[X, A, B, C, D, E](applyX: (A, B, C, D, E) => X, unapplyX: X => Option[(A, B, C, D, E)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E]): HasAdditionOperatorAndZero[X] = {
    new Product5HasAdditionOperatorAndZero[X, A, B, C, D, E](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid)
  }

  def apply[X, A, B, C, D, E, F](applyX: (A, B, C, D, E, F) => X, unapplyX: X => Option[(A, B, C, D, E, F)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F]): HasAdditionOperatorAndZero[X] = {
    new Product6HasAdditionOperatorAndZero[X, A, B, C, D, E, F](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid)
  }

  def apply[X, A, B, C, D, E, F, G](applyX: (A, B, C, D, E, F, G) => X, unapplyX: X => Option[(A, B, C, D, E, F, G)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G]): HasAdditionOperatorAndZero[X] = {
    new Product7HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H](applyX: (A, B, C, D, E, F, G, H) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H]): HasAdditionOperatorAndZero[X] = {
    new Product8HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I](applyX: (A, B, C, D, E, F, G, H, I) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I]): HasAdditionOperatorAndZero[X] = {
    new Product9HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J](applyX: (A, B, C, D, E, F, G, H, I, J) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J]): HasAdditionOperatorAndZero[X] = {
    new Product10HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid, jmonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K](applyX: (A, B, C, D, E, F, G, H, I, J, K) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K]): HasAdditionOperatorAndZero[X] = {
    new Product11HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid, jmonoid, kmonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L](applyX: (A, B, C, D, E, F, G, H, I, J, K, L) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L]): HasAdditionOperatorAndZero[X] = {
    new Product12HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid, jmonoid, kmonoid, lmonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M]): HasAdditionOperatorAndZero[X] = {
    new Product13HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid, jmonoid, kmonoid, lmonoid, mmonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N]): HasAdditionOperatorAndZero[X] = {
    new Product14HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid, jmonoid, kmonoid, lmonoid, mmonoid, nmonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O]): HasAdditionOperatorAndZero[X] = {
    new Product15HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid, jmonoid, kmonoid, lmonoid, mmonoid, nmonoid, omonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P]): HasAdditionOperatorAndZero[X] = {
    new Product16HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid, jmonoid, kmonoid, lmonoid, mmonoid, nmonoid, omonoid, pmonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P], qmonoid: HasAdditionOperatorAndZero[Q]): HasAdditionOperatorAndZero[X] = {
    new Product17HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid, jmonoid, kmonoid, lmonoid, mmonoid, nmonoid, omonoid, pmonoid, qmonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P], qmonoid: HasAdditionOperatorAndZero[Q], rmonoid: HasAdditionOperatorAndZero[R]): HasAdditionOperatorAndZero[X] = {
    new Product18HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid, jmonoid, kmonoid, lmonoid, mmonoid, nmonoid, omonoid, pmonoid, qmonoid, rmonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P], qmonoid: HasAdditionOperatorAndZero[Q], rmonoid: HasAdditionOperatorAndZero[R], smonoid: HasAdditionOperatorAndZero[S]): HasAdditionOperatorAndZero[X] = {
    new Product19HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid, jmonoid, kmonoid, lmonoid, mmonoid, nmonoid, omonoid, pmonoid, qmonoid, rmonoid, smonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P], qmonoid: HasAdditionOperatorAndZero[Q], rmonoid: HasAdditionOperatorAndZero[R], smonoid: HasAdditionOperatorAndZero[S], tmonoid: HasAdditionOperatorAndZero[T]): HasAdditionOperatorAndZero[X] = {
    new Product20HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid, jmonoid, kmonoid, lmonoid, mmonoid, nmonoid, omonoid, pmonoid, qmonoid, rmonoid, smonoid, tmonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P], qmonoid: HasAdditionOperatorAndZero[Q], rmonoid: HasAdditionOperatorAndZero[R], smonoid: HasAdditionOperatorAndZero[S], tmonoid: HasAdditionOperatorAndZero[T], umonoid: HasAdditionOperatorAndZero[U]): HasAdditionOperatorAndZero[X] = {
    new Product21HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid, jmonoid, kmonoid, lmonoid, mmonoid, nmonoid, omonoid, pmonoid, qmonoid, rmonoid, smonoid, tmonoid, umonoid)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)])(implicit amonoid: HasAdditionOperatorAndZero[A], bmonoid: HasAdditionOperatorAndZero[B], cmonoid: HasAdditionOperatorAndZero[C], dmonoid: HasAdditionOperatorAndZero[D], emonoid: HasAdditionOperatorAndZero[E], fmonoid: HasAdditionOperatorAndZero[F], gmonoid: HasAdditionOperatorAndZero[G], hmonoid: HasAdditionOperatorAndZero[H], imonoid: HasAdditionOperatorAndZero[I], jmonoid: HasAdditionOperatorAndZero[J], kmonoid: HasAdditionOperatorAndZero[K], lmonoid: HasAdditionOperatorAndZero[L], mmonoid: HasAdditionOperatorAndZero[M], nmonoid: HasAdditionOperatorAndZero[N], omonoid: HasAdditionOperatorAndZero[O], pmonoid: HasAdditionOperatorAndZero[P], qmonoid: HasAdditionOperatorAndZero[Q], rmonoid: HasAdditionOperatorAndZero[R], smonoid: HasAdditionOperatorAndZero[S], tmonoid: HasAdditionOperatorAndZero[T], umonoid: HasAdditionOperatorAndZero[U], vmonoid: HasAdditionOperatorAndZero[V]): HasAdditionOperatorAndZero[X] = {
    new Product22HasAdditionOperatorAndZero[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](applyX, unapplyX)(amonoid, bmonoid, cmonoid, dmonoid, emonoid, fmonoid, gmonoid, hmonoid, imonoid, jmonoid, kmonoid, lmonoid, mmonoid, nmonoid, omonoid, pmonoid, qmonoid, rmonoid, smonoid, tmonoid, umonoid, vmonoid)
  }

}

trait ProductGroups {
  def apply[X, A, B](applyX: (A, B) => X, unapplyX: X => Option[(A, B)])(implicit agroup: Group[A], bgroup: Group[B]): Group[X] = {
    new Product2Group[X, A, B](applyX, unapplyX)(agroup, bgroup)
  }

  def apply[X, A, B, C](applyX: (A, B, C) => X, unapplyX: X => Option[(A, B, C)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C]): Group[X] = {
    new Product3Group[X, A, B, C](applyX, unapplyX)(agroup, bgroup, cgroup)
  }

  def apply[X, A, B, C, D](applyX: (A, B, C, D) => X, unapplyX: X => Option[(A, B, C, D)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D]): Group[X] = {
    new Product4Group[X, A, B, C, D](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup)
  }

  def apply[X, A, B, C, D, E](applyX: (A, B, C, D, E) => X, unapplyX: X => Option[(A, B, C, D, E)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E]): Group[X] = {
    new Product5Group[X, A, B, C, D, E](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup)
  }

  def apply[X, A, B, C, D, E, F](applyX: (A, B, C, D, E, F) => X, unapplyX: X => Option[(A, B, C, D, E, F)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F]): Group[X] = {
    new Product6Group[X, A, B, C, D, E, F](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup)
  }

  def apply[X, A, B, C, D, E, F, G](applyX: (A, B, C, D, E, F, G) => X, unapplyX: X => Option[(A, B, C, D, E, F, G)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G]): Group[X] = {
    new Product7Group[X, A, B, C, D, E, F, G](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup)
  }

  def apply[X, A, B, C, D, E, F, G, H](applyX: (A, B, C, D, E, F, G, H) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H]): Group[X] = {
    new Product8Group[X, A, B, C, D, E, F, G, H](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I](applyX: (A, B, C, D, E, F, G, H, I) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I]): Group[X] = {
    new Product9Group[X, A, B, C, D, E, F, G, H, I](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J](applyX: (A, B, C, D, E, F, G, H, I, J) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J]): Group[X] = {
    new Product10Group[X, A, B, C, D, E, F, G, H, I, J](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup, jgroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K](applyX: (A, B, C, D, E, F, G, H, I, J, K) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K]): Group[X] = {
    new Product11Group[X, A, B, C, D, E, F, G, H, I, J, K](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup, jgroup, kgroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L](applyX: (A, B, C, D, E, F, G, H, I, J, K, L) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L]): Group[X] = {
    new Product12Group[X, A, B, C, D, E, F, G, H, I, J, K, L](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup, jgroup, kgroup, lgroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M]): Group[X] = {
    new Product13Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup, jgroup, kgroup, lgroup, mgroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N]): Group[X] = {
    new Product14Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup, jgroup, kgroup, lgroup, mgroup, ngroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O]): Group[X] = {
    new Product15Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup, jgroup, kgroup, lgroup, mgroup, ngroup, ogroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P]): Group[X] = {
    new Product16Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup, jgroup, kgroup, lgroup, mgroup, ngroup, ogroup, pgroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P], qgroup: Group[Q]): Group[X] = {
    new Product17Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup, jgroup, kgroup, lgroup, mgroup, ngroup, ogroup, pgroup, qgroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P], qgroup: Group[Q], rgroup: Group[R]): Group[X] = {
    new Product18Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup, jgroup, kgroup, lgroup, mgroup, ngroup, ogroup, pgroup, qgroup, rgroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P], qgroup: Group[Q], rgroup: Group[R], sgroup: Group[S]): Group[X] = {
    new Product19Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup, jgroup, kgroup, lgroup, mgroup, ngroup, ogroup, pgroup, qgroup, rgroup, sgroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P], qgroup: Group[Q], rgroup: Group[R], sgroup: Group[S], tgroup: Group[T]): Group[X] = {
    new Product20Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup, jgroup, kgroup, lgroup, mgroup, ngroup, ogroup, pgroup, qgroup, rgroup, sgroup, tgroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P], qgroup: Group[Q], rgroup: Group[R], sgroup: Group[S], tgroup: Group[T], ugroup: Group[U]): Group[X] = {
    new Product21Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup, jgroup, kgroup, lgroup, mgroup, ngroup, ogroup, pgroup, qgroup, rgroup, sgroup, tgroup, ugroup)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)])(implicit agroup: Group[A], bgroup: Group[B], cgroup: Group[C], dgroup: Group[D], egroup: Group[E], fgroup: Group[F], ggroup: Group[G], hgroup: Group[H], igroup: Group[I], jgroup: Group[J], kgroup: Group[K], lgroup: Group[L], mgroup: Group[M], ngroup: Group[N], ogroup: Group[O], pgroup: Group[P], qgroup: Group[Q], rgroup: Group[R], sgroup: Group[S], tgroup: Group[T], ugroup: Group[U], vgroup: Group[V]): Group[X] = {
    new Product22Group[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](applyX, unapplyX)(agroup, bgroup, cgroup, dgroup, egroup, fgroup, ggroup, hgroup, igroup, jgroup, kgroup, lgroup, mgroup, ngroup, ogroup, pgroup, qgroup, rgroup, sgroup, tgroup, ugroup, vgroup)
  }

}

trait ProductRings {
  def apply[X, A, B](applyX: (A, B) => X, unapplyX: X => Option[(A, B)])(implicit aring: Ring[A], bring: Ring[B]): Ring[X] = {
    new Product2Ring[X, A, B](applyX, unapplyX)(aring, bring)
  }

  def apply[X, A, B, C](applyX: (A, B, C) => X, unapplyX: X => Option[(A, B, C)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C]): Ring[X] = {
    new Product3Ring[X, A, B, C](applyX, unapplyX)(aring, bring, cring)
  }

  def apply[X, A, B, C, D](applyX: (A, B, C, D) => X, unapplyX: X => Option[(A, B, C, D)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D]): Ring[X] = {
    new Product4Ring[X, A, B, C, D](applyX, unapplyX)(aring, bring, cring, dring)
  }

  def apply[X, A, B, C, D, E](applyX: (A, B, C, D, E) => X, unapplyX: X => Option[(A, B, C, D, E)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E]): Ring[X] = {
    new Product5Ring[X, A, B, C, D, E](applyX, unapplyX)(aring, bring, cring, dring, ering)
  }

  def apply[X, A, B, C, D, E, F](applyX: (A, B, C, D, E, F) => X, unapplyX: X => Option[(A, B, C, D, E, F)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F]): Ring[X] = {
    new Product6Ring[X, A, B, C, D, E, F](applyX, unapplyX)(aring, bring, cring, dring, ering, fring)
  }

  def apply[X, A, B, C, D, E, F, G](applyX: (A, B, C, D, E, F, G) => X, unapplyX: X => Option[(A, B, C, D, E, F, G)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G]): Ring[X] = {
    new Product7Ring[X, A, B, C, D, E, F, G](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring)
  }

  def apply[X, A, B, C, D, E, F, G, H](applyX: (A, B, C, D, E, F, G, H) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H]): Ring[X] = {
    new Product8Ring[X, A, B, C, D, E, F, G, H](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I](applyX: (A, B, C, D, E, F, G, H, I) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I]): Ring[X] = {
    new Product9Ring[X, A, B, C, D, E, F, G, H, I](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J](applyX: (A, B, C, D, E, F, G, H, I, J) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J]): Ring[X] = {
    new Product10Ring[X, A, B, C, D, E, F, G, H, I, J](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring, jring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K](applyX: (A, B, C, D, E, F, G, H, I, J, K) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K]): Ring[X] = {
    new Product11Ring[X, A, B, C, D, E, F, G, H, I, J, K](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring, jring, kring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L](applyX: (A, B, C, D, E, F, G, H, I, J, K, L) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L]): Ring[X] = {
    new Product12Ring[X, A, B, C, D, E, F, G, H, I, J, K, L](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring, jring, kring, lring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M]): Ring[X] = {
    new Product13Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring, jring, kring, lring, mring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N]): Ring[X] = {
    new Product14Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring, jring, kring, lring, mring, nring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O]): Ring[X] = {
    new Product15Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring, jring, kring, lring, mring, nring, oring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P]): Ring[X] = {
    new Product16Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring, jring, kring, lring, mring, nring, oring, pring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P], qring: Ring[Q]): Ring[X] = {
    new Product17Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring, jring, kring, lring, mring, nring, oring, pring, qring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P], qring: Ring[Q], rring: Ring[R]): Ring[X] = {
    new Product18Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring, jring, kring, lring, mring, nring, oring, pring, qring, rring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P], qring: Ring[Q], rring: Ring[R], sring: Ring[S]): Ring[X] = {
    new Product19Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring, jring, kring, lring, mring, nring, oring, pring, qring, rring, sring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P], qring: Ring[Q], rring: Ring[R], sring: Ring[S], tring: Ring[T]): Ring[X] = {
    new Product20Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring, jring, kring, lring, mring, nring, oring, pring, qring, rring, sring, tring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P], qring: Ring[Q], rring: Ring[R], sring: Ring[S], tring: Ring[T], uring: Ring[U]): Ring[X] = {
    new Product21Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring, jring, kring, lring, mring, nring, oring, pring, qring, rring, sring, tring, uring)
  }

  def apply[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](applyX: (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V) => X, unapplyX: X => Option[(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)])(implicit aring: Ring[A], bring: Ring[B], cring: Ring[C], dring: Ring[D], ering: Ring[E], fring: Ring[F], gring: Ring[G], hring: Ring[H], iring: Ring[I], jring: Ring[J], kring: Ring[K], lring: Ring[L], mring: Ring[M], nring: Ring[N], oring: Ring[O], pring: Ring[P], qring: Ring[Q], rring: Ring[R], sring: Ring[S], tring: Ring[T], uring: Ring[U], vring: Ring[V]): Ring[X] = {
    new Product22Ring[X, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](applyX, unapplyX)(aring, bring, cring, dring, ering, fring, gring, hring, iring, jring, kring, lring, mring, nring, oring, pring, qring, rring, sring, tring, uring, vring)
  }

}
